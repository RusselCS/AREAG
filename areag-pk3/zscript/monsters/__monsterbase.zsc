class EnemySpawner : BasicActor
{
    Default
    {
        +NOINTERACTION;
        +THRUACTORS;
        +NOCLIP;
    }

    String sEnemyType;
    int iRespawnTime;
    int respawnCountdown;

    property EnemyType: sEnemyType;
    property RespawnTime: iRespawnTime;

    Actor activeEnemy;
    Actor player;
    bool awaitingRespawn;

    override void BasicInit() {
        spawnEnemy();
        player = GetPointer(AAPTR_PLAYER1);

        if(iRespawnTime == 0) {
            if(score == 0) {
                iRespawnTime = 30 * 35;
            } else {
                iRespawnTime = score * 35;
            }
        }
    }

    bool canPlayerSee() {
        return player.IsVisible(self, false);
    }

    void spawnEnemy() {
        bool sp;
        [sp, activeEnemy] = A_SpawnItemEx(sEnemyType);
        if(sp) {
            if(!bSTANDSTILL) {
                activeEnemy.score = score;
            }
            activeEnemy.bSTANDSTILL = bSTANDSTILL;
            activeEnemy.bDORMANT = bDORMANT;
            awaitingRespawn = false;
        } else {
            A_Log("[EnemySpawner] Enemy Spawn Failed!");
        }
    }

    override void BasicTick() {
        if(bDROPPED) {
            Destroy();
        }
        if(!bSTANDSTILL) {
            if(!awaitingRespawn) {
                if(!activeEnemy) {
                    respawnCountdown = iRespawnTime;
                    awaitingRespawn = true;
                }
            } else {
                if(!canPlayerSee()) {
                    respawnCountdown--;
                    if(respawnCountdown == 0) {
                        spawnEnemy();
                    }
                }
            }
        }
    }

    States
    {
    Spawn:
        TNT1 A 1;
        wait;
    ForceRespawn:
        TNT1 A 0 {
            if(!activeEnemy) {
                spawnEnemy();
            }
        }
        goto Spawn;
    }
}

class BasicEnemy : BasicActor
{
    Default
    {
        MONSTER;
        +FLOORCLIP;
        +SLIDESONWALLS;
        height 10;
        radius 5;
        renderstyle "translucent";
        alpha 1.0;
    }
    
    int kbTime;
    bool bInDeathSequence;
    int iDamageTick;
    int iDeathTick;
    int iDeathSequenceType;

    EnemyPatrolNode nextPatrol;

    Vector2 BaseScale;
    Vector2 BaseDimensions;

    override void BasicInit() {
        super.BasicInit();
        iDamageTick = 0;
        iDeathTick = 0;
        iDeathSequenceType = 0;

        if(bSTANDSTILL) {
            scale = scale * 0.5;
            SetState(ResolveState("TestSpawn"));
            bINVULNERABLE = true;
            bSHOOTABLE = false;
            bNOBLOOD = true;
        }

        BaseScale = scale;
        BaseDimensions = (radius, height);

        monsterInit();
    }

    virtual void monsterInit() {}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle) {
		int ang = inflictor.angle % 360;

        monsterPainSound(mod);
        iDamageTick = 4;

		if(mod == "SteelWhip" || mod == "LaserWhip") {
			A_SpawnItemEx("KnockBackTrail", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERSPRITEFRAME);
			A_ChangeVelocity(cos(ang)*90, sin(ang)*90, 0, CVF_REPLACE);
			kbTime = 2;
		} else if(mod == "TribalShield") {
            A_SpawnItemEx("KnockBackTrail", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERSPRITEFRAME);
			A_ChangeVelocity(cos(ang)*90, sin(ang)*90, 0, CVF_REPLACE);
			kbTime = 4;
        }

		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}

    override void Die(Actor source, Actor inflictor, int dmgflags, Name mod) {
        monsterPainSound(mod);
        monsterDeathSound(mod);
        super.Die(source, inflictor, dmgflags, mod);
    }

    virtual void monsterPainSound(Name mod) {}
    virtual void monsterDeathSound(Name mod) {}

	override void BasicTick() {
		super.BasicTick();
		tick_KnockBack();
        tick_DeathSequence();
        
        monsterTick();
	}

    // Enemies freeze after a hit.
    override void Tick() {
        if(iDamageTick == 0) {
            super.tick();
        } else {
            tick_DamageFlash();
        }
    }

    virtual void monsterTick() {}

    void tick_KnockBack() {
        if(kbTime > 0) {
			kbTime--;
			if(kbTime == 0) {
				A_ScaleVelocity(0.1);
			} else {
				A_SpawnItemEx("KnockBackTrail", 0, 0, 0, 0, 0, 0, 0, SXF_TRANSFERSPRITEFRAME);
			}
		}
    }

    void tick_DamageFlash() {
        if(health > 0) {
            if(iDamageTick > 1) {
                switch((iDamageTick-1) % 4) {
                    case 0:
                        A_SetTranslation("RedMap1");
                        break;
                    case 1:
                        A_SetTranslation("RedMap2");
                        break;
                    case 2:
                        A_SetTranslation("RedMap3");
                        break;
                    case 3:
                        A_SetTranslation("RedMap4");
                        break;
                }
            } else {
                A_SetTranslation("Def");
            }
            
            iDamageTick--;
            
        } else {
            iDamageTick = 0;
        }
    }

    action void A_DeathSequence(int type = EDS_FadeBurn) {
        A_ChangeFlag("NOINTERACTION", true);
        A_Stop();
        invoker.bInDeathSequence = true;
        invoker.iDeathSequenceType = type;
    }

    virtual void tick_DeathSequence() {
        if(bInDeathSequence) {
            switch(iDeathSequenceType) {
                default:
                case EDS_FadeBurn:
                    A_SpawnItemEx("EnemyDeathSmoke", frandom(-radius, radius), frandom(-radius, radius), frandom(0, height));
                    A_FadeOut(0.03);
                break;
                case EDS_VerticalSquash:
                    if(iDeathTick == 0) {
                        let fx = A_SpawnBasicEffect("EnemyDeathShadow", -0.1, 0, 0, 0, 0, 0, 0, SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERSCALE);
                        fx.tracer = self;

                    }

                    A_FaceTarget();
                    A_Warp(AAPTR_DEFAULT, 0, SignModTwo(iDeathTick) * 5, SignModTwo(iDeathTick) * 5, 0, WARPF_INTERPOLATE);
                    if(iDeathTick > 5) {
                        double fadeScale = 0.06;
                        A_SetScale(max(scale.x - BaseScale.x * fadeScale, 0.0), scale.y + BaseScale.y * fadeScale/2);

                        A_FadeOut(fadeScale);
                    }
                    double xScaleFactor = scale.x / BaseScale.x;
                    double yScaleFactor = scale.y / BaseScale.y;
                    
                    A_SpawnBasicEffect("EnemyDeathSmoke", fRandRange(BaseDimensions.x * xScaleFactor), fRandRange(BaseDimensions.x * xScaleFactor), fRandom(0, BaseDimensions.y * yScaleFactor));
                break;
            }
            iDeathTick++;
        }
    }

    void StopLedgeFall() {
        if(abs(GetZAt(pos.x + vel.x, pos.y + vel.y, 0, GZF_ABSOLUTEPOS|GZF_ABSOLUTEANG) - floorz) > maxstepheight * 2) {
            A_Stop();
        }
    }

    States
    {
    Spawn:
        TNT1 A 0;
        stop;
    TestSpawn:
        "----" "#" 1;
        loop;
    }
}

enum EnemyDeathSequences
{
    EDS_FadeBurn,
    EDS_VerticalSquash
}

class EnemyPatrolNode : Actor
{
    // To fill in later
}

class EnemyDeathSmoke : BasicEffect
{
    Default
    {
        +FORCEXYBILLBOARD;
    }
    States
    {
    Spawn:
        EDT0 ABCDEFG 1;
        stop;
    }
}

class BasicTrackingPoint : Actor
{
    Default
    {
        +NOINTERACTION;
        +NOGRAVITY;
        +VULNERABLE;
        health 1;
        renderstyle "none";
    }

    States
    {
    Spawn:
        PLAY A 1;
        loop;
    Death:
        TNT1 A 1;
        stop;
    }
}

class EnemyDeathShadow : BasicEffect
{
    Default
    {
        +BASICEFFECT.MATCHTRACERSCALE;
        +BASICACTOR.DIEWITHTRACER;
        Renderstyle "Stencil";
        StencilColor "00 00 00";
    }

    override void BasicTick() {
        A_Warp(AAPTR_TRACER, -0.1, 0, 0, 0, WARPF_INTERPOLATE);
    }
}

extend class ZSCPlayerPawn {

    const WATER_GRAVITY_MULT = 0.2;
    const WATER_JUMP_MULT = 0.65;

    int iButtons, iOldButtons;

    bool bOnGround;
    bool bJumpCancel;
    bool bLegsInWater;
    bool bHeadInWater;

    int iSpeedInv;
    int iJumpInv;

    float fBaseSpeed;
    float fBaseJump;
    float fStrafeSpeed;

    float fBaseGravity;

    double prevBobXFracMult;
    double prevBobYFracMult;
    double prevViewBob;

    double zVelLerp;
    double lastVelZ;
    double lerpVelZ;
    double lastZVelLerp;

    void AREAGMoveInit() {
        Thing_ChangeTID(0, PlayerNumber()+1000);
        ACS_NamedExecuteAlways("movement_standing", 0);
	    ACS_NamedExecuteAlways("movement_water_player", 0);
        prevBobXFracMult = 0.0;
        prevBobYFracMult = 0.0;
        prevViewBob = ViewBob;
        lerpVelZ = 0.0;
        zVelLerp = 0.0;
        lastZVelLerp = 0.0;

        iButtons = GetPlayerInput(INPUT_BUTTONS);
		iOldButtons = GetPlayerInput(INPUT_OLDBUTTONS);
        bJumpCancel = true;
        bOnGround = true;
        bLegsInWater = false;
        bheadInWater = false;
        fBaseGravity = gravity;
        
        iJumpInv = CountInv("BaseJumpSpeed");
        fBaseJump = float(iJumpInv) / 100.0;
        AREAGUpdateSpeeds();
    }

    void AREAGUpdateSpeeds() {
        iSpeedInv = CountInv("BaseMoveSpeed");
        fBaseSpeed = float(iSpeedInv) / 100.0;
        fStrafeSpeed = fBaseSpeed * 0.78089;
    }

    void AREAGMoveTick() {
        iOldButtons = iButtons;
		iButtons = GetPlayerInput(INPUT_BUTTONS);

        // On Ground bool based on Marrub/Allie's Lithium code.
        bOnGround = pos.z ~== floorz || bONMOBJ || bMBFBOUNCER;

        // VelZ interpolations also based on Lithium.
        if(Vel.Z - lastVelZ > double.Epsilon)
        {
            if(lastVelZ >= 0) zVelLerp += Vel.Z;
            else              zVelLerp += 5 - lastVelZ * 2;
        }

        zVelLerp = AREAG_Func.Lerp(zVelLerp, 0, 0.277);
        lastVelZ = Vel.Z;

        lastZVelLerp = lerpVelZ;
        lerpVelZ = AREAG_Func.Lerp(lerpVelZ, zVelLerp, 0.42);

        if(!bOnGround && viewbob != 0.0) {
            viewbob = 0.0;
        }

        if(bOnGround && viewbob != 1.0) {
            viewbob = 1.0;
        }

        if(bOnGround && !bJumpCancel) {
            bJumpCancel = true;
        }

        // JUMP CANCEL
        if(AREAG_Func.checkButtonReleased(BT_JUMP, iButtons, iOldButtons) && vel.z > 0 && bJumpCancel)
		{
			ThrustThingZ(0, 0, 0, 0);
			bJumpCancel = false;
		}

        // STRAFERUN HANDLER
        if(((iButtons & BT_FORWARD) || (iButtons & BT_BACK)) && ((iButtons & BT_MOVELEFT) || (iButtons & BT_MOVERIGHT)))
		{
            if(!(speed ~== fStrafeSpeed)) {
                speed = fStrafeSpeed;
            }
		}
		else
		{
            if(!(speed ~== fBaseSpeed)) {
                speed = fBaseSpeed;
            }
		}

        // WATER
		if(CountInv("LegsUnderwater")>0)
		{
			if(!bLegsInWater) {
				gravity = fBaseGravity * WATER_GRAVITY_MULT;
				jumpz = fBaseJump * WATER_JUMP_MULT;
				A_GiveInventory("WaterSpeed", 1);
				bLegsInWater = true;
			}
		}
		else
		{
			if(bLegsInWater) {
				gravity = fBaseGravity;
				jumpz = fBaseJump;
				A_TakeInventory("WaterSpeed", 1);
				bLegsInWater = false;
			}
		}
		if(CountInv("HeadUnderwater")>0)
		{
			if(!bHeadInWater)
			{
				A_GiveInventory("BreathCooldown", 1);
				bHeadInWater = true;
			}
			if(CountInv("BreathCooldown") == 0)
			{
				if(CountInv("BreathTime") > 0)
				{
					A_TakeInventory("BreathTime", 10);
				}
				else
				{
					//Thing_Damage2(0, 5, "Drowning");
                    A_DamageSelf(5, "Drowning", DMSS_FOILINVUL|DMSS_FOILBUDDHA|DMSS_NOPROTECT|DMSS_NOFACTOR, "None", "None", AAPTR_NULL);
				}
				A_GiveInventory("BreathCooldown", 1);
			}
		}
		else
		{
			GiveInventory("BreathTime", 100);
			bHeadInWater = false;
		}


        if(iJumpInv != CountInv("BaseJumpSpeed"))
		{
            iJumpInv = CountInv("BaseJumpSpeed");
            fBaseJump = float(iJumpInv) / 100.0;
            AREAGUpdateSpeeds();
			if(blegsInWater)
			{
				jumpz = fBaseJump * WATER_JUMP_MULT;
			}
			else
			{
				jumpz = fBaseJump;
			}
		}
		
		// SPEED MANIPULATION (eg. Gear Greaves)
		if(iSpeedInv != CountInv("BaseMoveSpeed"))
		{
			AREAGUpdateSpeeds();
		}
    }

    override vector2 BobWeapon(double ticfrac)
    {
    if(!Player) return (0, 0);
    let wep = Player.ReadyWeapon;

    if(!wep || wep.bDONTBOB) return (0, 0);

    vector2 p[2];

    double ang = wep.BobSpeed * 128 * Player.GetWBobSpeed() * (Level.Time) * 0.05;
    prevViewBob = AREAG_Func.Lerp(prevViewBob, ViewBob, ticfrac/2);
    let xFracMult = cos(ang) * prevViewBob * 0.8;
    let yFracMult = 0.5-abs(sin(ang)) * prevViewBob * 0.5;
    double bobx = 0;
    double boby = 0;

    bobx = Player.Bob * wep.BobRangeX;
    boby = Player.Bob * wep.BobRangeY;
    bobx *= xFracMult;
    boby *= yFracMult;
    p[0] = (bobx, boby+5.0);

    bobx = Player.Bob * wep.BobRangeX;
    boby = Player.Bob * wep.BobRangeY;
    bobx *= prevBobXFracMult;
    boby *= prevBobYFracMult;
    p[1] = (bobx, boby+5.0);

    prevBobXFracMult = xFracMult;
    prevBobYFracMult = yFracMult;
    
    
    vector2 interp = p[0] * (1 - 0.5) + p[1] * 0.5;
    interp.y += AREAG_Func.Lerp(lerpVelZ, vel.z, 0.5);

    return interp;
    }

}
extend class AREAGPlayerPawn {
	mixin AREAG_Common;
	
    const COYOTE_TIME = 5;

    bool bJumpCancel;
    bool bLegsInWater;
    bool bHeadInWater;

    double dBaseSpeed;
    double dBaseJump;

    property RunSpeed: dBaseSpeed;
    property JumpSpeed: dBaseJump;

    double dStrafeSpeed;
    double dSR50Speed;

    double dBaseGravity;

    double prevBobXFracMult;
    double prevBobYFracMult;
    double prevViewBob;

    double dBaseRadius;
	double dBaseHeight;
    double dBaseViewHeight;
    double dBaseStepHeight;
    double dBaseAttackZOffset;

    int airTime;
    int jumpDelay;
    int iBaseStepHeight;

    int iStepCD;

    Actor aTPPoint;

    double dViewHeightOffset;
    double dOldViewHeightOffset;
    int iStepCountdown;
    const STEPCD_MAX = 5;
    double dOldViewHeight;
    bool eyesInit;

    void AREAGMoveInit() {
        Thing_ChangeTID(0, PlayerNumber()+1000);
        prevBobXFracMult = 0.0;
        prevBobYFracMult = 0.0;
        prevViewBob = ViewBob;
        iStepCD = 0;
        eyesInit = false;

        dBaseRadius = radius;
	    dBaseHeight = height;
        dBaseViewHeight = viewHeight;
        dBaseStepHeight = maxstepheight;
        dBaseAttackZOffset = attackZOffset;
        dViewHeightOffset = 0.0;
        
        setBaseJumpSpeed(dBaseJump);
        setBaseWalkSpeed(dBaseSpeed);

        bJumpCancel = true;
        bLegsInWater = false;
        bheadInWater = false;
        dBaseGravity = gravity;
        airTime = 0;
        jumpDelay = 0;
    }

    void AREAGUpdateSpeeds() {
        dStrafeSpeed = dBaseSpeed * 0.78087;
        dSR50Speed = dBaseSpeed * 0.7071;
    }

    void AREAGMoveThink() {
        int SR = checkSR(iButtons);
        if(SR > 0)
		{  
            if(SR == 40 && !(speed ~== dStrafeSpeed)) {
                speed = dStrafeSpeed;
            } else if(SR == 50 && !(speed ~== dSR50Speed)) {
                speed = dSR50Speed;
            }
		}
		else
		{
            if(!(speed ~== dBaseSpeed)) {
                speed = dBaseSpeed;
            }
		}
    }

    void AREAGMoveTick() {

        // FALL STUN
        if(bOnGround && lastZVel < -FallingScreamMinSpeed) {
            if(CountInv("DroneFlag") > 0) {
                A_GiveInventory("ScreenShakeTime", 2);
                A_SpawnItemEx("AREAGCrashLand");
                A_StartSound("drone/crashland", CHAN_BODY);
            } else {
                A_GiveInventory("FallStunTime", 140);
                A_GiveInventory("ScreenShakeTime", 5);
                A_SpawnItemEx("AREAGCrashLand");
                A_StartSound("player/crashland", CHAN_BODY);
            }
        }

        // JUMPING
        if((bOnGround || airTime <= COYOTE_TIME) && (iButtons & BT_JUMP) && jumpDelay == 0 && CountInv("FallStunTime") == 0) {
            jumpDelay = 10;
            Vel.Z = JumpZ * 35 / TICRATE;
            A_StartSound("*jump", CHAN_BODY);
        }

        if(checkReleased(BT_JUMP, iButtons, iOldButtons) && vel.z > 0 && bJumpCancel)
		{
			ThrustThingZ(0, 0, 0, 0);
			bJumpCancel = false;
		}

        if(airTime > COYOTE_TIME && vel.z < 0) {
			bJumpCancel = false;
        }

        // WATER
		if(CountInv("LegsUnderwater")>0)
		{
			if(!bLegsInWater) {
				gravity = dBaseGravity * WATER_GRAVITY_MULT;
                if(vel.z < 0) {
                    A_ChangeVelocity(vel.x, vel.y, vel.z * (WATER_GRAVITY_MULT * 2), CVF_REPLACE);
                }
				updateJumpSpeed();
				A_GiveInventory("WaterSpeed", 1);
				bLegsInWater = true;
			}
		}
		else
		{
			if(bLegsInWater) {
                gravity = dBaseGravity;
				updateJumpSpeed();
				A_TakeInventory("WaterSpeed", 1);
				bLegsInWater = false;
			}
		}
		if(CountInv("HeadUnderwater")>0)
		{
			if(!bHeadInWater)
			{
				A_GiveInventory("BreathCooldown", 1);
				bHeadInWater = true;
			}
			if(CountInv("BreathCooldown") == 0)
			{
				if(CountInv("BreathTime") > 0)
				{
					A_TakeInventory("BreathTime", 10);
				}
				else
				{
					//Thing_Damage2(0, 5, "Drowning");
                    A_DamageSelf(5, "Drowning", DMSS_FOILINVUL|DMSS_FOILBUDDHA|DMSS_NOPROTECT|DMSS_NOFACTOR, "None", "None", AAPTR_NULL);
				}
				A_GiveInventory("BreathCooldown", 1);
			}
		}
		else
		{
			GiveInventory("BreathTime", 100);
			bHeadInWater = false;
		}

        // -- GROUND CHECKS --
        // STAIRS
        if(!bOnGround && bOldOnGround) {
            if(pos.z - floorz <= maxstepheight && vel.z < 0) {
                double offs = pos.z - floorz;
                iStepCountdown = STEPCD_MAX;
                dViewHeightOffset += offs;
                // player.ViewHeight += 0.1; - set this later on...
                changeViewHeight(offs, false);
                Warp(self, 0, 0, -offs, 0, WARPF_INTERPOLATE);

                bOnGround = true;
            }
        } else {
            if(dViewHeightOffset > 0) {
                double offs = dViewHeightOffset/iStepCountdown;
                iStepCountdown--;
                dOldViewHeightOffset = dViewHeightOffset;
                dViewHeightOffset-=offs;
                Viewheight -= offs;
            } else if(dOldViewHeightOffset > 0) {
                dViewHeightOffset = 0.0;
                dOldViewHeightOffset = 0.0;
                changeViewHeight(dBaseViewHeight, true);
            }
        }

        if(dOldViewHeight != viewHeight || CountInv("ForceEyeZRefresh") > 0) {
            //A_Log(String.format("Eyes Z: %f", pos.z + viewHeight));
            dOldViewHeight = viewHeight;
            A_TakeInventory("ForceEyeZRefresh", 1);
        }

        if(!bOnGround) {
            if(viewbob != 0.0 && pos.z - floorz > 16.0) {
                viewbob = 0.0;
            }
            airTime++;
        }

        if(bOnGround && viewbob != 1.0) {
            viewbob = 1.0;
        }

        if(bOnGround) {
            if(!bJumpCancel) {
                bJumpCancel = true;
            }
            if(jumpDelay > 0) {
                jumpDelay--;
            }
            if(airTime > 0) {
                jumpDelay = min(jumpDelay, airTime);
                airTime = 0;
            }
        }

        // PIT TELEPORTER
        if(!aTPPoint) {
            bool spSuccess = false;
            while(!spSuccess) {
                [spSuccess, aTPPoint] = A_SpawnItemEx("AREAGPitReturnPoint");
            }
        } else {
            if(bOnGround) {
                if(CountInv("PitTeleport") == 0) {
                    aTPPoint.A_Warp(AAPTR_PLAYER1, -Vel.X*4, Vel.Y*4, -(Pos.Z-floorz), 0, WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEANGLE);
                    aTPPoint.A_SetAngle(angle);
                } else {
                    A_Stop();
                    aTPPoint.A_Warp(AAPTR_PLAYER1, 0, 0, -(Pos.Z-floorz), 0, WARPF_NOCHECKPOSITION|WARPF_MOVEPTR);
                    A_TakeInventory("PitTeleport", 999);
                }
            }
        }
    }

    void changeViewHeight(int amt, bool setoradd) {
        ACS_NamedExecuteAlways("status_updateviewheight", 0, amt, setoradd);
    }

    override vector2 BobWeapon(double ticfrac)
    {
        if(!Player) return (0, 0);
        let wep = Player.ReadyWeapon;
        if(!wep || wep.bDONTBOB) return (0, 0); 

        if(CountInv("DroneFlag") == 0) {
            if(CountInv("DashFlag") == 0) {
                return humanWeaponBob(wep, ticfrac);
            } else {
                return dashWeaponBob(wep, ticfrac);
            }
        } else {
            return droneWeaponBob(wep, ticfrac);
        }
    }

    vector2 humanWeaponBob(Weapon wep, double ticfrac)
    {
        Vector2 p[2], r;
		Vector2 result;

		let player = self.player;
		if (!player) return (0, 0);
		let weapon = player.ReadyWeapon;

		if (weapon == null || weapon.bDontBob)
		{
			return (0, 0);
		}

		// [XA] Get the current weapon's bob properties.
		int bobstyle = weapon.BobStyle;
		double BobSpeed = (weapon.BobSpeed * 128);
		double Rangex = weapon.BobRangeX;
		double Rangey = weapon.BobRangeY;

		for (int i = 0; i < 2; i++)
		{
			// Bob the weapon based on movement speed. ([SP] And user's bob speed setting)
			double angle = (BobSpeed * player.GetWBobSpeed() * 35 /	TICRATE*(Level.maptime - 1 + i)) * (360. / 8192.);

			// [RH] Smooth transitions between bobbing and not-bobbing frames.
			// This also fixes the bug where you can "stick" a weapon off-center by
			// shooting it when it's at the peak of its swing.
			if (curbob != player.bob)
			{
				if (abs(player.bob - curbob) <= 1)
				{
					curbob = player.bob;
				}
				else
				{
					double zoom = MAX(1., abs(curbob - player.bob) / 40);
					if (curbob > player.bob)
					{
						curbob -= zoom;
					}
					else
					{
						curbob += zoom;
					}
				}
			}

			// The weapon bobbing intensity while firing can be adjusted by the player.
			double BobIntensity = (WF_WEAPONBOBBING) ? 1. : player.GetWBobFire();

			if (curbob != 0)
			{
				//[SP] Added in decorate player.viewbob checks
				double bobx = (player.bob * BobIntensity * Rangex * ViewBob);
				double boby = (player.bob * BobIntensity * Rangey * ViewBob);

                r.X = bobx*cos(angle);
				r.Y = 0.5f * (boby * (1. + (cos(angle * 2))));

				// switch (bobstyle)
				// {
				// case Bob_Normal:
				// 	r.X = bobx * cos(angle);
				// 	r.Y = boby * abs(sin(angle));
				// 	break;

				// case Bob_Inverse:
				// 	r.X = bobx*cos(angle);
				// 	r.Y = boby * (1. - abs(sin(angle)));
				// 	break;

				// case Bob_Alpha:
				// 	r.X = bobx * sin(angle);
				// 	r.Y = boby * abs(sin(angle));
				// 	break;

				// case Bob_InverseAlpha:
				// 	r.X = bobx * sin(angle);
				// 	r.Y = boby * (1. - abs(sin(angle)));
				// 	break;

				// case Bob_Smooth:
				// 	r.X = bobx*cos(angle);
				// 	r.Y = 0.5f * (boby * (1. - (cos(angle * 2))));
				// 	break;

				// case Bob_InverseSmooth:
				// 	r.X = bobx*cos(angle);
				// 	r.Y = 0.5f * (boby * (1. + (cos(angle * 2))));
				// }
			}
			else
			{
				r = (0, 0);
			}
            p[i] = r;
		}
		return p[0] * (1. - ticfrac) + p[1] * ticfrac;

        // vector2 p[2];
        
        // double ang = wep.BobSpeed * 128 * Player.GetWBobSpeed() * (Level.Time) * 0.08;
        // prevViewBob = Lerp(prevViewBob, ViewBob, ticfrac/2);
        // let xFracMult = cos(ang) * prevViewBob * 0.8;
        // let yFracMult = 0.5-abs(sin(ang)) * prevViewBob * 0.5;
        // double bobx = 0;
        // double boby = 0;

        // bobx = Player.Bob * wep.BobRangeX;
        // boby = Player.Bob * wep.BobRangeY;
        // bobx *= xFracMult;
        // boby *= yFracMult;
        // p[0] = (bobx, boby+5.0);

        // bobx = Player.Bob * wep.BobRangeX;
        // boby = Player.Bob * wep.BobRangeY;
        // bobx *= prevBobXFracMult;
        // boby *= prevBobYFracMult;
        // p[1] = (bobx, boby+5.0);

        // prevBobXFracMult = xFracMult;
        // prevBobYFracMult = yFracMult;
        
        // vector2 interp = p[0] * (1 - 0.5) + p[1] * 0.5;
        // interp.y += Lerp(lerpVelZ, vel.z, 0.5);

        // // if(abs(sin(ang)) < 0.2 && bOnGround && AREAGIsWalking()) {
        // //     if(iStepCD == 0) {
        // //         A_PlaySound("*footstep", CHAN_BODY);
        // //         iStepCD = 1;
        // //     }
        // // } else {
        // //     iStepCD = 0;
        // // }

        // return interp;
    }

    static int checkSR(int iButtons) {
        if(iButtons & BT_MOVELEFT || iButtons & BT_MOVERIGHT) {
            if(iButtons & BT_FORWARD || iButtons & BT_BACK) { // Pressing forward / back
                if((iButtons & BT_LEFT || iButtons & BT_RIGHT) && iButtons & BT_STRAFE) {
                    return 50;
                }
                return 40;
            }
            return 0;
        }
        return 0;
    }

    Name getClydeSoundClass() {
        // if(CountInv("SteamGreavesFlag") > 0) {
        //     return "steamclyde";
        // } else {
        //     return "clyde";
        // }
        return "clyde";
    }

    void setBaseJumpSpeed(double which) {
        dBaseJump = which;
        updateJumpSpeed();
    }

    void updateJumpSpeed() {
        if(CountInv("DroneFlag") == 0) {
            if(CountInv("LegsUnderwater"))
            {
                jumpz = dBaseJump * WATER_JUMP_MULT;
            }
            else
            {
                jumpz = dBaseJump;
            }
        } else {
            jumpz = 10.0;
        }
    }

    void setBaseWalkSpeed(double which) {
        dBaseSpeed = which;
        AREAGUpdateSpeeds();
    }
}

class AREAGCrashLand : BasicEffect
{
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_Explode(30, 128, 0, 0, 128);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 45, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 90, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 135, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 180, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 225, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 270, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 315, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeLeft", 48, 0, 8, 0, 0, 0, 0, SXF_ABSOLUTEANGLE);
		
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 45+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 90+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 135+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 180+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 225+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 270+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 315+22.5, SXF_ABSOLUTEANGLE);
		TNT1 A 0 A_SpawnItemEx("AREAGLandSmokeRight", 48, 0, 8, 0, 0, 0, 22.5, SXF_ABSOLUTEANGLE);
		stop;
	}
}

class ForceEyeZRefresh : Once {}
class IncreaseEyeHeight : Once {}
class TransitionEyeHeight : Once {}

class AREAGLandSmokeLeft : BasicEffect
{
    Default
    {
        alpha 0.7;
        -FORCEXYBILLBOARD;
    }

    action void A_DustRotate() {
        A_ChangeVelocity(4, 0, 0, CVF_RELATIVE|CVF_REPLACE);
        A_SetAngle(angle+12);
    }

	States
	{
	Spawn:
        MDAD HHHIIIJJJ 2 A_DustRotate();
		stop;
	}
}

class AREAGLandSmokeRight : AREAGLandSmokeLeft
{
    action void A_DustRotate() {
        A_ChangeVelocity(8, 0, 0, CVF_RELATIVE|CVF_REPLACE);
        A_SetAngle(angle-4);
    }
}

class AREAGPitReturnPoint : Actor
{
    Default
    {
        +NOINTERACTION;
        +NOCLIP;
        Renderstyle "None";
    }
    States
    {
    Spawn:
        TROO A 1;
        wait;
    }
}

class PitTeleport : Once {}

// MOVEMENT FLAGS //
class OnGround : Once {}
class JumpCancel : Once {}
class HeadUnderwater : Once {}
class LegsUnderwater : Once {}

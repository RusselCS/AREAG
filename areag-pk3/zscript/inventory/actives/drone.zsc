class DronePickup : BasicInventory
{
    Default
    {
        inventory.pickupmessage "";
        +INVENTORY.AUTOACTIVATE;
        +FLOATBOB;
        +NOGRAVITY;
        Height 64; // tall
        Scale 1.0;
    }
	States
	{
	SpawnFrames:
		SDRO C 1;
		loop;
	Pickup:
		TNT1 A 0 ACS_NamedExecuteAlways("pickups_displayMessage", 0, PICKTYPE_TREASURE, PICKMSG_SPIDERDRONE);
		TNT1 A 0 A_GiveInventory("DroneBattery", 100);
		TNT1 A 0 A_GiveInventory("DroneTrigger", 1);
		stop;
	}
}

class DroneUseAnim : Once {}
class DroneTrigger : BasicActiveTrigger
{
    Default
    {
        inventory.icon "INICSPID";
    }
	States
	{
	TreasureUse:
		TNT1 A 0 A_GiveInventory("DroneUseAnim", 1);
		fail;
	}
}

extend class AREAGProtoWeapon {
    States
    {
    DroneUse:
		// Because this is morphing, I'm unsure if these items stick around
		// so this item needs to take away the framework controlling items
		// BEFORE morphing, because the weapon may be reset before anything can
		// go away
		TNT1 A 2;
		WDRO ABC 1;
		WDRO A 0 A_StartSound("weapon/dynamitethrow", CHAN_WEAPON);
		WDRO E 0 A_FireProjectile("DroneTransitionMissile");
		WDRO DE 1;
		WDRO D 6;
		TNT1 A 0 A_TakeInventory("DroneUseAnim", 1);
		TNT1 A 0 A_GiveInventory("DroneActivate", 1);
		goto Ready;
    }
}

class AREAGDrone : AREAGProtoPlayer
{
    mixin AREAG_Common;
    
    const HP_TIME_MAX = 10;
    int iHpDrainTime;

    int iWalkCooldown;
    double prevBobYFracMult;
    double prevViewBob;
    bool bLegsInWater;
    
    double fBaseSpeed;
    double fStrafeSpeed;
    double fSR50Speed;
    double fBaseJump;
    double fBaseGravity;

    Default
    {
        Height 24;
        Radius 12;
        player.viewheight 20;
        player.morphweapon "DronePlasmaGun";
        Player.AttackZOffset 5; // 41 - view height
        player.gruntspeed 8;
        player.soundclass "clyde";
        speed 0.85;
	    player.jumpz 10;
        gravity 1.2;
        friction 1.0;
        maxstepheight 16;
    }

    override void AREAGInit() {
        iWalkCooldown = 0;
        prevBobYFracMult = 0.0;
        prevViewBob = 0.0;
        fBaseSpeed = speed;
        fStrafeSpeed = fBaseSpeed * 0.78089;
        fSR50Speed = fBaseSpeed * 0.7071;
        bLegsInWater = false;
        fBaseJump = jumpz;
        fBaseGravity = gravity;
        iHpDrainTime = HP_TIME_MAX;
    }

    override void AREAGTick() {
        if(bOnGround && lastZVel < -GruntSpeed) {
            A_StartSound("*droneland", CHAN_5);
            iWalkCooldown = 5;
        }

        if(bOnGround && AREAGIsWalking()) {
            if(iWalkCooldown == 0) {
                A_StartSound("*dronewalk", CHAN_5);
                iWalkCooldown = 5;
            }
        }

        // WATER
		if(CountInv("LegsUnderwater")>0)
		{
			if(!bLegsInWater) {
				gravity = fBaseGravity * WATER_GRAVITY_MULT;
				jumpz = fBaseJump * WATER_JUMP_MULT;
				A_GiveInventory("WaterSpeed", 1);
				bLegsInWater = true;
			}
		}
		else
		{
			if(bLegsInWater) {
				gravity = fBaseGravity;
				jumpz = fBaseJump;
				A_TakeInventory("WaterSpeed", 1);
				bLegsInWater = false;
			}
		}

        if(iWalkCooldown > 0) {
            iWalkCooldown--;
        }

        if(!bOnGround && viewbob != 0.0 && pos.z - floorz > 16.0) {
            viewbob = 0.0;
        }

        if(bOnGround && viewbob != 1.0) {
            viewbob = 1.0;
        }

        if(iHpDrainTime == 0) {
            health--;
            if(health <= 0) {
                revertDrone();
            }
            iHpDrainTime = HP_TIME_MAX;
        } else if(CountInv("MapTransition") == 0) {
            iHpDrainTime--;
        }
    }

    override void AREAGThink() {
        int SR = checkSR(iButtons);
        if(SR > 0)
		{  
            if(SR == 40 && !(speed ~== fStrafeSpeed)) {
                speed = fStrafeSpeed;
            } else if(SR == 50 && !(speed ~== fSR50Speed)) {
                speed = fSR50Speed;
            }
		}
		else
		{
            if(!(speed ~== fBaseSpeed)) {
                speed = fBaseSpeed;
            }
		}
    }

    void revertDrone() {
        ACS_NamedExecuteAlways("drone_disengage", 0);
    }

    override vector2 BobWeapon(double ticfrac)
    {
        if(!Player) return (0, 0);
        let wep = Player.ReadyWeapon;

        if(!wep || wep.bDONTBOB) return (0, 0);

        vector2 p[2];

        double ang = wep.BobSpeed * 128 * Player.GetWBobSpeed() * (Level.Time) * 0.4;
        prevViewBob = Lerp(prevViewBob, ViewBob, ticfrac/2);
        let yFracMult = 0.05-sin(ang) * prevViewBob * 0.05;
        double boby = 0;

        boby = Player.Bob * wep.BobRangeY;
        boby *= yFracMult;
        p[0] = (0, boby+5.0);

        boby = Player.Bob * wep.BobRangeY;
        boby *= prevBobYFracMult;
        p[1] = (0, boby+5.0);

        prevBobYFracMult = yFracMult;
        
        vector2 interp = p[0] * (1 - 0.5) + p[1] * 0.5;
        interp.y += Lerp(lerpVelZ, vel.z, 0.5);

        // if(abs(sin(ang)) < 0.2 && bOnGround && AREAGIsWalking()) {
        //     if(iStepCD == 0) {
        //         A_PlaySound("*footstep", CHAN_BODY);
        //         iStepCD = 1;
        //     }
        // } else {
        //     iStepCD = 0;
        // }

        return interp;
    }

    override void Die(Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath) {
        revertDrone();
        super.Die(source, inflictor, dmgflags, MeansOfDeath);
    }

    static int checkSR(int iButtons) {
        if(iButtons & BT_MOVELEFT || iButtons & BT_MOVERIGHT) {
            if(iButtons & BT_FORWARD || iButtons & BT_BACK) { // Pressing forward / back
                if((iButtons & BT_LEFT || iButtons & BT_RIGHT) && iButtons & BT_STRAFE) {
                    return 50;
                }
                return 40;
            }
            return 0;
        }
        return 0;
    }
}

class DronePlasmaGun : Weapon
{
    Default
    {
        +WEAPON.WIMPY_WEAPON;
    }
	States
	{
	Ready:
		SDRW A 1 A_WeaponReady;
		Loop;
	Deselect:
		SDRW A 1 A_Lower;
		Loop;
	Select:
		SDRW A 1 A_Raise;
		Loop;
	Fire:
		SDRW B 0 A_StartSound("weapon/dronelaser", CHAN_WEAPON);
		SDRW B 0 A_FireProjectile("DroneActivator", 0, 0, 0, 0);
		SDRW B 0 A_FireProjectile("DroneLaser", 0, 0, -8, 0);
		SDRW B 0 A_FireProjectile("DroneLaser", 0, 0, 8, 0);
		SDRW B 2 BRIGHT;
		SDRW CD 4;
		SDRW A 8;
		Goto Ready;
	}
}

class DroneBattery : Counter { Default { inventory.maxamount 100; } }
class PlayerTempHealth : Counter {}
class MapTransition : Once {}

class DroneFlag : Once {}
class DroneActivate : CustomInventory
{
	States
	{
	Pickup:
		TNT1 A 0 A_GiveInventory("DroneFlag", 1);
		TNT1 A 0 ACS_NamedExecuteAlways("drone_activate", 0);
		stop;
	}
}

class DroneTransitionMissile : BasicProjectile
{
    Default
    {
        PROJECTILE;
        +THRUACTORS;
        +BLOCKASPLAYER;
        -NOGRAVITY;
        gravity 1.2;
        bouncetype "Doom";
        bouncefactor 0.0;
        wallbouncefactor 0.0;
        DamageFunction (0);
        Speed 24;
    }
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 ThrustThingZ(0, 30, 0, 0);
		TNT1 A 0 A_TransferPointer(AAPTR_DEFAULT, AAPTR_TARGET, AAPTR_DEFAULT, AAPTR_MASTER);
		SDRO A 4;
		SDRO B 1;
		wait;
	}
}

class DroneLaser : BasicFastProjectile
{
    Default
    {
        PROJECTILE;
        +BLOODSPLATTER;
        -ACTIVATEIMPACT;
        +FORCEXYBILLBOARD;
        missiletype "DroneLaserTrail";
        missileheight 8;
        renderstyle "add";
        Radius 6;
        Height 7;
        DamageFunction (5);
        speed 45;
        scale 0.2;
        reactiontime 10;
    }
	States
	{
	Spawn:
		DLAZ A 1 A_Countdown;
		loop;
	}
}

class DroneActivator : DroneLaser
{
    Default
    {
        DamageFunction (0);
        renderstyle "none";
        missiletype "";
        +ACTIVATEIMPACT;
    }
}

class DroneLaserTrail : BasicEffect
{
    Default
    {
        +FORCEXYBILLBOARD;
        renderstyle "add";
        scale 0.2;
    }
	States
	{
	Spawn:
		DLAZ AAA 1;
		stop;
	}
}

class DronePlayerDummy : Actor
{
    Default
    {
        -SOLID;
        +NOCLIP;
        renderstyle "translucent";
        Alpha 1.0;
    }
	States
	{
	Spawn:
		PLAY A 1;
		loop;
	}
}

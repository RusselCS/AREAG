struct AREAG_Func {
    static bool checkButtonReleased(int button, int buttons, int oldButtons)
    {
        if(!(buttons & button) && (oldButtons & button))
        {
            return true;
        }
        return false;
    }

    static double Lerp(double a, double b, double t)
	{
		return (1 - t) * a + t * b;
	}

    static bool collidingBoxes(Actor a, Actor b, double rad) {
        double diffX = abs(a.pos.x - b.pos.x) - rad;
        double diffY = abs(a.pos.y - b.pos.y) - rad;

        return diffX <= 0 && diffY <= 0;
    }
}

// DEBUG FUNCTIONS
class HitboxParticle : BasicEffect
{
    Default
    {
        +FORCEXYBILLBOARD;
        translation "0:255=104:104";
    }

    States
    {
    Spawn:
        CHWP BB 1 bright;
        stop;
    }
}

class HitboxActor : Actor
{
    override void Tick() {
        Super.Tick();

        for(int i = 0; i < radius; i++) {
            A_SpawnItemEx("HitboxParticle", radius, i, 1);
            A_SpawnItemEx("HitboxParticle", radius, -i, 1);
            A_SpawnItemEx("HitboxParticle", -radius, i, 1);
            A_SpawnItemEx("HitboxParticle", -radius, -i, 1);
            A_SpawnItemEx("HitboxParticle", i, radius, 1);
            A_SpawnItemEx("HitboxParticle", -i, radius, 1);
            A_SpawnItemEx("HitboxParticle", i, -radius, 1);
            A_SpawnItemEx("HitboxParticle", -i, -radius, 1);

            A_SpawnItemEx("HitboxParticle", radius, i, height);
            A_SpawnItemEx("HitboxParticle", radius, -i, height);
            A_SpawnItemEx("HitboxParticle", -radius, i, height);
            A_SpawnItemEx("HitboxParticle", -radius, -i, height);
            A_SpawnItemEx("HitboxParticle", i, radius, height);
            A_SpawnItemEx("HitboxParticle", -i, radius, height);
            A_SpawnItemEx("HitboxParticle", i, -radius, height);
            A_SpawnItemEx("HitboxParticle", -i, -radius, height);
        }

        for(int i = 0; i < height; i++) {
            A_SpawnItemEx("HitboxParticle", radius, radius, i);
            A_SpawnItemEx("HitboxParticle", radius, -radius, i);
            A_SpawnItemEx("HitboxParticle", -radius, radius, i);
            A_SpawnItemEx("HitboxParticle", -radius, -radius, i);
        }
    }
}

// SWITCH CRYSTALS
class ZSCSwitchCrystal : Actor
{
    //$Category AREAG-Map Tools
    //$Title Crystal Switch
	//$Sprite E0WAD0
    //$NotAngled

    bool bSwitchOn;

    Default
    {
        +SOLID;
        +SHOOTABLE;
        +NOBLOOD;
        health 1;
        mass 9999;
        height 56;
        radius 16;
        scale 1.5;
    }

    override void PostBeginPlay()
    {
        super.PostBeginPlay();
        bSwitchOn = false;
    }
	
    override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle) {
        
        bool success = false;

        if(!bSwitchOn) {
            if(score == 0) {
                SetState(ResolveState("SwitchOn"));
            } else {
                SetState(ResolveState("SwitchOnOff"));
            }
            success = true;
            bSwitchOn = true;
        }

        if(success) {
            A_PlaySound("misc/switchon", CHAN_BODY, 1.0, false, ATTN_NONE);
            runSpecial();
        }
        
        return 0;
    }

    void switchOff() {
        bSwitchOn = false;
        A_PlaySound("misc/switchoff", CHAN_BODY, 1.0, false, ATTN_NONE);
        runSpecial();
    }

    void runSpecial() {
        A_CallSpecial(special, args[0], 0, bSwitchOn, args[3], args[4]);
    }

    States
    {
    Spawn:
        SCRY A 0;
        SCRY A 1;
        wait;
    SwitchOn:
		SCRY B 1;
        wait;
    SwitchOnOff:
        SCRY B 0 A_SetTics(score);
        SCRY B 0 switchOff();
		goto Spawn;
    }
}

class CrystalSwitchPop : Actor
{
    Default
    {
        +NOCLIP;
        +NOINTERACTION;
        +MISSILE;
        +THRUACTORS;
        height 2;
        radius 1;
    }

    States
    {
    Spawn:
        TNT1 A 0;
        TNT1 A 0 A_Explode(5, 10, 0, 0, 10);
        stop;
    }
}

// PUSH BLOCKS, FLOOR SWITCHES
class AREAGPushBlock : Actor
{
    //$Category AREAG-Map Tools
    //$Title Large Stone Block
	//$Sprite PCBAA0
    //$NotAngled

    Default
    {
        +SOLID;
        +PUSHABLE;
        +SLIDESONWALLS;
        Height 64;
        Radius 30;
        maxstepheight 0;
        Scale 2.0;
    }

    States
    {
    Spawn:
        PCBA B 1;
        loop;
    }
}

class AREAGPushBlockSmall : AREAGPushBlock
{
    //$Category AREAG-Map Tools
    //$Title Small Metal Block
	//$Sprite PCBAA0
    //$NotAngled

    Default
    {
        Height 32;
        Radius 16;
        Scale 1.0;
    }

    States
    {
    Spawn:
        PCBA A 1;
        loop;
    }
}

class ZSCFloorSwitch : Actor
{
    //$Category AREAG-Map Tools
    //$Title Floor Switch
	//$Sprite E0WAB0
    //$NotAngled

    static const String[] steps = {
        "AREAGPlayer",
        "DronePlayerDummy",
        "AREAGPushBlock",
        "AREAGPushBlockSmall"
    };

    Default
    {
        -SOLID;
        radius 32;
        height 10;
        renderstyle "none";
    }

    bool bActive;
    bool bEndState;
    override void Tick() {

        super.Tick();
        bool bSwitchState = false;

        double fCheckRadius = radius*3;

        if(!bEndState) {
            for(int i = 0; i < ZSCFloorSwitch.steps.Size(); i++) {
                if(CheckProximity(ZSCFloorSwitch.steps[i], fCheckRadius, 1, CPXF_NOZ|CPXF_SETTARGET)) {
                    bSwitchState = bSwitchState || (target.pos.z ~== pos.z && AREAG_Func.collidingBoxes(target, self, target.radius+self.radius+self.score));
                }
            }

            if(bSwitchState != bActive) {
                bActive = bSwitchState;
                ACS_ExecuteAlways(args[0], 0, bActive, args[3], args[4]);

                if(bActive) {
                    A_PlaySound("misc/floorswitchon", CHAN_BODY, 1.0, false, ATTN_NONE);
                    SetState(ResolveState("SwitchOn"));
                } else {
                    A_PlaySound("misc/floorswitchoff", CHAN_BODY, 1.0, false, ATTN_NONE);
                    SetState(ResolveState("SwitchOff"));
                }
            }
        }
    }

    override void PostBeginPlay() {
        super.PostBeginPlay();
        bActive = false;
        bEndState = false;
        SetState(ResolveState("SwitchOff"));
    }

    States
    {
    SwitchOn:
		SCRY B 1;
        wait;
    SwitchOff:
        SCRY A 1;
        wait;
    }
}

// DOORS
class DoorManager : Actor
{
    //$Category AREAG-Map Tools
    //$Title Door Controller
	//$Sprite E0WAC0
    //$Arg0 Key Number
    //$Arg1 Front Room ID
    //$Arg2 Back Room ID
    //$Arg3 Open Height
    //$Arg4 Closed Height

    Sector sDoor;
    array<Line> doorLines;
    int time;
    bool bApplyDoor;
    bool bJammedDoor;

    bool voidLine(Line ln) {
        return ln.BackSector == null;
    }

    bool hasKey(int keyId) {
        if(keyId == 0) {
            return true;
        } else {
            return CountInv(KeyBase.keys[keyId-1], AAPTR_PLAYER1);
        }
    }

    static void applyDoor(Line ln, int id, int maxHeight, int minHeight) {
        ln.Activation |= 1<<1;
        ln.Activation |= 1<<10;
        ln.Flags |= 0x00000200; // ELineFlags.ML_REPEAT_SPECIAL;

        ln.special = 226;
        ln.args[0] = -int(Name("map_door"));
        ln.args[1] = 0;
        ln.args[2] = id;
        ln.args[3] = maxHeight;
        ln.args[4] = minHeight;
    }

    static void revokeDoor(Line ln, int id, int maxHeight, int minHeight) {
        ln.special = 0;
        ln.args[0] = 0;
        ln.args[1] = 0;
        ln.args[2] = 0;
        ln.args[3] = 0;
        ln.args[4] = 0;
    }

    override void PostBeginPlay() {
        super.PostBeginPlay();

        sDoor = CurSector;
        bJammedDoor = score > 0;

        time = 70;
        bApplyDoor = !bJammedDoor;

        if(args[3] == 0) {
            args[3] = ceilingz;
        }

        if(args[4] == 0) {
            args[4] = floorz;
        }
        
        for(int i = 0; i < CurSector.Lines.size(); i++) {
            if(voidLine(CurSector.Lines[i])) {
                CurSector.Lines[i].Flags |= 0x00000010; // ELineFlags.ML_DONTPEGBOTTOM;
            } else {
                CurSector.Lines[i].Flags |= 0x00000002; // ELineFlags.ML_BLOCKMONSTERS;
            }
        }

        Ceiling_MoveToValue(tid, 96, args[4]);
    }

    override void Tick() {
        super.Tick();

        if(hasKey(args[0]) && !bJammedDoor) {
            if(bApplyDoor)
            {
                bApplyDoor = false;
                for(int i = 0; i < CurSector.Lines.size(); i++) {
                    if(!voidLine(CurSector.Lines[i])) {
                        applyDoor(CurSector.Lines[i], tid, args[3], args[4]);
                    }
                }
            }
        } else if(!hasKey(args[0]) || bJammedDoor) {
            if(!bApplyDoor)
            {
                bApplyDoor = true;
                for(int i = 0; i < CurSector.Lines.size(); i++) {
                    if(!voidLine(CurSector.Lines[i])) {
                        revokeDoor(CurSector.Lines[i], tid, args[3], args[4]);
                    }
                }
            }
        }
    }
}

// AREA TRANSITION GATES
class AreaGate : SecActHitFloor
{
    //$Category AREAG-Map Tools
    //$Title Area Gate
	//$Sprite E0WAC0
    //$Arg0 Map ID
    //$Arg1 Door ID

    override void PostBeginPlay() {
        A_Log("HELLO!!!");
        int id = args[0];
        int door = args[1];

        special = 226;
        args[0] = -int(Name("map_switchto"));
        args[1] = 0;
        args[2] = id;
        args[3] = door;
        args[4] = false;
    }
}

// THE SHOP
class ZSCNumber : Actor
{
    int iNumberToDraw;

    Default
    {
        -SOLID;
        +NOGRAVITY;
        +THRUACTORS;
    }

    override void PostBeginPlay()
    {
        super.PostBeginPlay();

        iNumberToDraw = random(0, random(1, 100)*10);
        int digits = countDigits(iNumberToDraw);
        int start = digits/2;

        for(int i = 0; i < digits; i++)
        {
            Actor act;
            bool res;
            [res, act] = A_SpawnItemEx("ZSCDigit", 0, ((i-start)*10));
            let actb = ZSCDigit(act);
            actb.iDigit = getDigit(iNumberToDraw, i);
            actb.iIndex = i-start;
            act.Tracer = self;
        }
    }

    override void Tick()
    {
        super.Tick();
        A_Face(Players[ConsolePlayer].MO);
    }

    private int countDigits(int input)
    {
        int res = 0;

        while(input > 0) {
            res++;
            input /= 10;
        }

        return res;
    }

    private int getDigit(int number, int index)
    {
        for(int i = 0; i < index; i++)
        {
            number /= 10;
        }

        int excess = (number / 10) * 10;

        return number - excess;
    }

    States
    {
    Spawn:
        TNT1 A 1;
        loop;
    }
}

class ZSCDigit : Actor
{
    int iDigit;
    int iIndex;
    int iTime;

    Default
    {
        +NOGRAVITY;
        +FORCEXYBILLBOARD;
    }

    override void Tick() {
        super.Tick();
        
        self.sprite = GetSpriteIndex(name("NUM1"));
        self.frame = max(0, iDigit);

        A_Warp(AAPTR_TRACER, 0, iIndex * 10, 0, 0, WARPF_INTERPOLATE);
    }

    States
    {
    Spawn:
        NUM1 A 1;
        loop;
    }
}

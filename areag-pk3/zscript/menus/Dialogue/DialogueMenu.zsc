class DialogueHandler : ZFHandler {
    // A reference to the menu we want to modify - the menu has to set this
    // to itself.
    DialogueMenu menu;

    override void buttonClickCommand(ZFButton caller, String command) {
        // Check if the command matches the button's command.
        if (command == 'firstButtonClick') {
            
        }
    }
}

enum DialogueState {
    DGS_NONE = -1,
    DGS_LEFT,
    DGS_RIGHT
}

class DialogueMenu : ZFGenericMenu {
    // Store a reference to the frame now that we want to change it later.
    ZFFrame frame;

    // Dialogue state information
    int tick;
    int stateTick;
    int sframe;
    DialogueState lastState;
    DialogueState dgState;

    // Dialogue screen elements
    int bordersIdx;
    int nameBoxIdx;
    NMImage leftSpeaker;
    NMImage rightSpeaker;
    int textBoxIdx;
    NMLabel leftNameTag;
    NMLabel rightNameTag;

    Array<NMElement> elems;

    Font textFont;
    Font nameFont;

    Vector2 imgCenter;
    Vector2 baseres;

    ShapeInfo borderIntroLeft;
    ShapeInfo borderIntroRight;
    ShapeInfo borderLeft;
    ShapeInfo borderRight;
    NMShape borders;

    Vector2 messagePos;
    Array<DialogueMessage> dgMessages;
    int dgCurrent;

    const UPDATE_SPEED = 8.0;

    override void init(Menu parent) {

        tick = 0;
        stateTick = 0;
        sframe = 0;
        dgCurrent = -1;
        lastState = DGS_NONE;
        dgState = DGS_NONE;
        textFont = "DIAGFONT";
        nameFont = "AREAFONT";


        imgCenter = (350, 0);

        // This must be called to ensure that the menu is set up properly.
        Super.init(parent);
        // ZForms menus work by using a "virtual" resolution which means that
        // you only have to design the menu for this resolution.
        // Here we'll use a typical monitor resolution, but this can be anything,
        // even 320x200.
        baseRes = (1600, 900);
        setBaseResolution(baseRes);
        populateCoords();

        // Here we make a frame - it needs to be positioned right, and big enough
        // to contain the elements we want inside it.
        self.frame = ZFFrame.create(
            (0, 0),
            (baseRes.x, baseRes.y)
        );
        frame.pack(mainFrame);

        leftSpeaker = NMImage.create(ZFImage.create(
            imgCenter,
            (900, 900), // max scale 3
            alignment: ZFElement.AlignType_BottomCenter
        ), UPDATE_SPEED);
        elems.push(leftSpeaker);
        //elems[leftSpeaker].myName = "leftSpeaker";

        rightSpeaker = NMImage.create(ZFImage.create(
            imgCenter,
            (900, 900),
            alignment: ZFElement.AlignType_BottomCenter
        ), UPDATE_SPEED);
        elems.push(rightSpeaker);

        borders = NMShape.create(ZFShape.create(
            (0, 0),
            baseRes,
            borderRight,
            "DG_OFRMX",
            ZFElement.AlignType_TopCenter
        ), UPDATE_SPEED);        
        elems.push(borders);

        textBoxIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            // This argument controls the position - 50 pixels under the label.
            (  0, 0),
            // This argument controls the size. Here we match STARTAN2.
            baseRes,
            // The texture name.
            image: "DG_SPBOX",
            alignment: ZFElement.AlignType_TopCenter
        ), UPDATE_SPEED));

        // nameBoxIdx = elems.size();
        // elems.push(NMImage.create(ZFImage.create(
        //     (  0, 0),
        //     (1600, 900),
        //     alignment: ZFElement.AlignType_TopCenter
        // ), UPDATE_SPEED));

        leftNameTag = NMLabel.create(ZFLabel.create(
            (NAMETAG_X, NAMETAG_Y),
            (1600, 900),
            fnt: nameFont,
            alignment: ZFElement.AlignType_BottomLeft,
            textScale: NAMETAG_SCALE
        ), UPDATE_SPEED);
        elems.push(leftNameTag);

        rightNameTag = NMLabel.create(ZFLabel.create(
            (-NAMETAG_X, NAMETAG_Y),
            (1600, 900),
            fnt: nameFont,
            alignment: ZFElement.AlignType_BottomRight,
            textScale: NAMETAG_SCALE
        ), UPDATE_SPEED);
        elems.push(rightNameTag);

        for(int i = 0; i < elems.size(); i++) {
            elems[i].pack(frame);
        }

        SetMouseCapture(false);
        createNextImages();

        stageDialogue(true);
    }

    const NAMETAG_X = 100;
    const NAMETAG_Y = -212;
    const NAMETAG_SCALE = 1.1;

    const NAMETAG_X_SCROLL = 200;

    const SPEAKER_SCALE_ACTIVE = 1.500;
    const SPEAKER_SCALE_INACTIVE = 1.000;

    const SPEAKER_POS_ACTIVE = -171;
    const SPEAKER_POS_INACTIVE = -671;

    const IMG_SCALE_INTRO = 1.5;

    const MSG_BODY_SCALE = 1.35;

    uint oldTime;

    override void drawer() {
        for(int i = 0; i < elems.size(); i++) {
            elems[i].drawer();
        }

        if(dgCurrent > -1) {
            for(int i = 0; i < dgMessages.size(); i++) {
                dgMessages[i].drawer(oldTime);
            }
        }
        oldTime = MSTime();

        super.drawer();
    }

    int stateTime()
    {
        return tick - stateTick;
    }

    void swapSides()
    {
        if(dgState == DGS_LEFT || dgState == DGS_RIGHT)
        {
            if(dgState == DGS_LEFT)
                changeState(DGS_RIGHT);
            else
                changeState(DGS_LEFT);
        }
    }

    void changeState(DialogueState st)
    {
        if(st != dgState) {
            sframe = 0;
            stateTick = tick;
            lastState = dgState;
            dgState = st;
        } else {
            return;
        }

        let activePos = (SPEAKER_POS_ACTIVE, 0);
        let inactivePos = (SPEAKER_POS_INACTIVE, 0);

        let activeScale = (SPEAKER_SCALE_ACTIVE, SPEAKER_SCALE_ACTIVE);
        let inactiveScale = (SPEAKER_SCALE_INACTIVE, SPEAKER_SCALE_INACTIVE);

        if(dgState != DGS_NONE && lastState == DGS_NONE) { // intro
            elems[textBoxIdx].setScale((1.0, 1.0) * IMG_SCALE_INTRO);
            elems[textBoxIdx].setTScale((1.0, 1.0));
            elems[textBoxIdx].setAlpha(0.0);
            elems[textBoxIdx].setTAlpha(1.0);

            switch(dgState) {
                case DGS_RIGHT:
                    leftSpeaker.setScale(inactiveScale * IMG_SCALE_INTRO);
                    leftSpeaker.setTScale(inactiveScale);
                    leftSpeaker.setAlpha(0.0);
                    leftSpeaker.setTAlpha(1.0);
                    leftSpeaker.setPos(imgCenter + IMG_SCALE_INTRO * inactivePos);
                    leftSpeaker.setTPos(imgCenter + inactivePos);

                    leftNameTag.setAlpha(0.0);
                    leftNameTag.setTAlpha(0.0);
                    leftNameTag.setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    leftNameTag.setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    rightSpeaker.setScale(activeScale * IMG_SCALE_INTRO);
                    rightSpeaker.setTScale(activeScale);
                    rightSpeaker.setAlpha(0.0);
                    rightSpeaker.setTAlpha(1.0);
                    rightSpeaker.setPos(imgCenter - IMG_SCALE_INTRO * activePos);
                    rightSpeaker.setTPos(imgCenter - activePos);

                    rightNameTag.setAlpha(0.0);
                    rightNameTag.setTAlpha(1.0);
                    rightNameTag.setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    rightNameTag.setTPos((-NAMETAG_X, NAMETAG_Y));

                    borders.setShape(borderIntroRight);
                    borders.setTShape(borderRight);
                    borders.setAlpha(0.0);
                    borders.setTAlpha(1.0);
                    break;
                case DGS_LEFT:
                    leftSpeaker.setScale(activeScale * IMG_SCALE_INTRO);
                    leftSpeaker.setTScale(activeScale);
                    leftSpeaker.setAlpha(0.0);
                    leftSpeaker.setTAlpha(1.0);
                    leftSpeaker.setPos(imgCenter + IMG_SCALE_INTRO * activePos);
                    leftSpeaker.setTPos(imgCenter + activePos);

                    leftNameTag.setAlpha(0.0);
                    leftNameTag.setTAlpha(1.0);
                    leftNameTag.setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    leftNameTag.setTPos((NAMETAG_X, NAMETAG_Y));

                    rightSpeaker.setScale(inactiveScale * IMG_SCALE_INTRO);
                    rightSpeaker.setTScale(inactiveScale);
                    rightSpeaker.setAlpha(0.0);
                    rightSpeaker.setTAlpha(1.0);
                    rightSpeaker.setPos(imgCenter - IMG_SCALE_INTRO * inactivePos);
                    rightSpeaker.setTPos(imgCenter - inactivePos);

                    rightNameTag.setAlpha(0.0);
                    rightNameTag.setTAlpha(0.0);
                    rightNameTag.setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    rightNameTag.setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));

                    borders.setShape(borderIntroLeft);
                    borders.setTShape(borderLeft);
                    borders.setAlpha(0.0);
                    borders.setTAlpha(1.0);
                    break;
            }
            return;
        }

        if(dgState != DGS_NONE && lastState != DGS_NONE) { // swap sides
            switch(dgState) {
                case DGS_RIGHT:
                    leftSpeaker.setTScale(inactiveScale);
                    leftSpeaker.setTAlpha(1.0);
                    leftSpeaker.setTPos(imgCenter + inactivePos);

                    leftNameTag.setTAlpha(0.0);
                    leftNameTag.setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    rightSpeaker.setTScale(activeScale);
                    rightSpeaker.setTAlpha(1.0);
                    rightSpeaker.setTPos(imgCenter - activePos);

                    rightNameTag.setTAlpha(1.0);
                    rightNameTag.setTPos((-NAMETAG_X, NAMETAG_Y));

                    borders.setTShape(borderRight);
                    break;
                case DGS_LEFT:
                    leftSpeaker.setTScale(activeScale);
                    leftSpeaker.setTAlpha(1.0);
                    leftSpeaker.setTPos(imgCenter + activePos);

                    leftNameTag.setTAlpha(1.0);
                    leftNameTag.setTPos((NAMETAG_X, NAMETAG_Y));

                    rightSpeaker.setTScale(inactiveScale);
                    rightSpeaker.setTAlpha(1.0);
                    rightSpeaker.setTPos(imgCenter - inactivePos);

                    rightNameTag.setTAlpha(0.0);
                    rightNameTag.setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));

                    borders.setTShape(borderLeft);
                    break;
            }
            return;
        }

        if(dgState == DGS_NONE && lastState != DGS_NONE) { // exit
            elems[textBoxIdx].setTScale((1.0, 1.0) * IMG_SCALE_INTRO);
            elems[textBoxIdx].setScale((1.0, 1.0));
            elems[textBoxIdx].setTAlpha(0.0);
            elems[textBoxIdx].setAlpha(1.0);

            switch(lastState) {
                case DGS_RIGHT:
                    leftSpeaker.setTScale(inactiveScale * IMG_SCALE_INTRO);
                    leftSpeaker.setScale(inactiveScale);
                    leftSpeaker.setTAlpha(0.0);
                    leftSpeaker.setAlpha(1.0);
                    leftSpeaker.setTPos(imgCenter + IMG_SCALE_INTRO * inactivePos);
                    leftSpeaker.setPos(imgCenter + inactivePos);

                    leftNameTag.setTAlpha(0.0);
                    leftNameTag.setAlpha(0.0);
                    leftNameTag.setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    leftNameTag.setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    rightSpeaker.setTScale(activeScale * IMG_SCALE_INTRO);
                    rightSpeaker.setScale(activeScale);
                    rightSpeaker.setTAlpha(0.0);
                    rightSpeaker.setAlpha(1.0);
                    rightSpeaker.setTPos(imgCenter - IMG_SCALE_INTRO * activePos);
                    rightSpeaker.setPos(imgCenter - activePos);

                    rightNameTag.setTAlpha(0.0);
                    rightNameTag.setAlpha(1.0);
                    rightNameTag.setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    rightNameTag.setPos((-NAMETAG_X, NAMETAG_Y));

                    borders.setTShape(borderIntroRight);
                    borders.setShape(borderRight);
                    borders.setTAlpha(0.0);
                    borders.setAlpha(1.0);
                    break;
                case DGS_LEFT:
                    leftSpeaker.setTScale(activeScale * IMG_SCALE_INTRO);
                    leftSpeaker.setScale(activeScale);
                    leftSpeaker.setTAlpha(0.0);
                    leftSpeaker.setAlpha(1.0);
                    leftSpeaker.setTPos(imgCenter + IMG_SCALE_INTRO * activePos);
                    leftSpeaker.setPos(imgCenter + activePos);

                    leftNameTag.setTAlpha(0.0);
                    leftNameTag.setAlpha(1.0);
                    leftNameTag.setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    leftNameTag.setPos((NAMETAG_X, NAMETAG_Y));

                    rightSpeaker.setTScale(inactiveScale * IMG_SCALE_INTRO);
                    rightSpeaker.setScale(inactiveScale);
                    rightSpeaker.setTAlpha(0.0);
                    rightSpeaker.setAlpha(1.0);
                    rightSpeaker.setTPos(imgCenter - IMG_SCALE_INTRO * inactivePos);
                    rightSpeaker.setPos(imgCenter - inactivePos);

                    rightNameTag.setTAlpha(0.0);
                    rightNameTag.setAlpha(0.0);
                    rightNameTag.setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    rightNameTag.setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));

                    borders.setTShape(borderIntroLeft);
                    borders.setShape(borderLeft);
                    borders.setTAlpha(0.0);
                    borders.setAlpha(1.0);
                    break;
            }
            return;
        }
    }

    int inputDelay;

    override void ticker()
    {
        let st = stateTime();

        if(inputDelay > 0) {
            inputDelay--;
        }

        if(dgState == DGS_NONE && lastState != DGS_NONE) // closing menu now...
        {
            if(borders.getAlpha() ~== 0.0) {
                Close();
            }
        }
        else
        {
            let dgMsg = dgMessages[dgCurrent];
            if(!dgMsg.isTyping()) {
                if(dgMsg.isFinished()) {
                    setNextButton(nextMessageImage);
                } else {
                    setNextButton(nextLineImage);
                }
            } else {
                setNextButton(null);
            }
        }

        tick++;
    }

    override bool MenuEvent (int mkey, bool fromcontroller)
	{
		switch (mkey)
		{
        case MKEY_Enter:
            let msg = dgMessages[dgCurrent];
            if(inputDelay == 0) {
                if(!msg.isFinished()) {
                    if(!msg.isTyping()) {
                        MenuSound("dialogue/next");
                        msg.next(false, -textFont.getHeight() * MSG_BODY_SCALE);
                    } else {
                        msg.skipTyping();
                    }
                } else {
                    MenuSound("dialogue/next");
                    msg.dismiss(NAMETAG_X_SCROLL);
                    setNextButton(null);
                    stageDialogue(false);
                }
                inputDelay = 8;
            }
            return true;
		case MKEY_Back:
			Close();
			MenuSound (GetCurrentMenu() != null? "menu/backup" : "menu/clear");
			return true;
		}
		return false;
	}

    Array<NMImage> nextImages;
    NMImage nextLineImage;
    NMImage nextMessageImage;
    NMImage nextImageActive;

    const nextImageScale = 0.3;

    void createNextImages() {

        let imgSize = (512, 512);
        let nextImagePos = baseRes - (imgSize * nextImageScale) - (baseRes * 0.03);

        let img = ZFImage.create(
                nextImagePos,
                imgSize * nextImageScale,
                image: "DG_OARNL",
                imageScale: (nextImageScale, nextImageScale)
                );
        nextLineImage = DGNextLine.make(img, UPDATE_SPEED);

        nextMessageImage = DGNextPage.make(
            ZFImage.create(
                nextImagePos,
                imgSize * nextImageScale,
                image: "DG_OARNP",
                imageScale: (nextImageScale, nextImageScale)
                ),
            UPDATE_SPEED
        );

        nextImages.push(nextLineImage);
        nextImages.push(nextMessageImage);

        elems.push(nextLineImage);
        elems.push(nextMessageImage);

        nextLineImage.setHidden(true);
        nextMessageImage.setHidden(true);

        nextLineImage.pack(frame);
        nextMessageImage.pack(frame);
    }

    bool setNextButton(NMImage button) {

        if(button == nextImageActive)
            return false;
        
        let idx = nextImages.find(button);

        for(int i = 0; i < nextImages.size(); i++) {
            nextImages[i].setHidden(true);
        }

        if(idx != -1 && button != null) {
            button.setHidden(false);
        }

        nextImageActive = button;
        return true;
    }

    // Population functions
    // Shape population
    void populateCoords()
    {
        borderLeft = ShapeInfo.create(baseRes);
        borderIntroLeft = ShapeInfo.create(baseRes);
        borderRight = ShapeInfo.create(baseRes);
        borderIntroRight = ShapeInfo.create(baseRes);

        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.660, -0.150));
        borderLeft.pushVC(( 0.700,  0.000));
        borderLeft.pushVC(( 1.000,  0.000));
        borderLeft.pushVC(( 1.000,  0.000));
        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.660, -0.150));
        borderLeft.pushVC(( 0.730,  0.320));
        borderLeft.pushVC(( 1.000,  0.240));
        borderLeft.pushVC(( 1.000,  0.240));
        borderLeft.pushVC(( 0.000,  1.000));
        borderLeft.pushVC(( 0.100,  1.000));
        borderLeft.pushVC(( 0.780,  1.000));
        borderLeft.pushVC(( 0.800,  1.000));
        borderLeft.pushVC(( 1.070,  1.000));
        borderLeft.pushVC(( 1.070,  1.000));

        borderLeft.pushTriangle((0, 1, 7));
        borderLeft.pushTriangle((0, 6, 7));
        borderLeft.pushTriangle((6, 7, 13));
        borderLeft.pushTriangle((6, 12, 13));
        borderLeft.pushTriangle((1, 2, 8));
        borderLeft.pushTriangle((1, 7, 8));
        borderLeft.pushTriangle((2, 3, 9));
        borderLeft.pushTriangle((2, 8, 9));
        borderLeft.pushTriangle((8, 9, 15));
        borderLeft.pushTriangle((8, 14, 15));
        borderLeft.pushTriangle((3, 4, 10));
        borderLeft.pushTriangle((3, 9, 10));
        borderLeft.pushTriangle((4, 5, 11));
        borderLeft.pushTriangle((4, 10, 11));
        borderLeft.pushTriangle((10, 11, 17));
        borderLeft.pushTriangle((10, 16, 17));
       

        borderRight.pushVC(( 0.000,  0.000));
        borderRight.pushVC(( 0.000,  0.000));
        borderRight.pushVC(( 0.300,  0.000));
        borderRight.pushVC(( 0.340, -0.150));
        borderRight.pushVC(( 0.340, -0.150));
        borderRight.pushVC(( 1.000,  0.000));
        borderRight.pushVC(( 0.000,  0.000));
        borderRight.pushVC(( 0.000,  0.240));
        borderRight.pushVC(( 0.270,  0.320));
        borderRight.pushVC(( 0.340, -0.150));
        borderRight.pushVC(( 1.000,  0.000));
        borderRight.pushVC(( 1.000,  0.000));
        borderRight.pushVC((-0.070,  1.000));
        borderRight.pushVC((-0.070,  1.000));
        borderRight.pushVC(( 0.200,  1.000));
        borderRight.pushVC(( 0.220,  1.000));
        borderRight.pushVC(( 0.900,  1.000));
        borderRight.pushVC(( 1.000,  1.000));

        borderRight.pushTriangle((0, 1, 7));
        borderRight.pushTriangle((0, 6, 7));
        borderRight.pushTriangle((6, 7, 13));
        borderRight.pushTriangle((6, 12, 13));
        borderRight.pushTriangle((1, 2, 8));
        borderRight.pushTriangle((1, 7, 8));
        borderRight.pushTriangle((2, 3, 9));
        borderRight.pushTriangle((2, 8, 9));
        borderRight.pushTriangle((8, 9, 15));
        borderRight.pushTriangle((8, 14, 15));
        borderRight.pushTriangle((3, 4, 10));
        borderRight.pushTriangle((3, 9, 10));
        borderRight.pushTriangle((4, 5, 11));
        borderRight.pushTriangle((4, 10, 11));
        borderRight.pushTriangle((10, 11, 17));
        borderRight.pushTriangle((10, 16, 17));

        let offset = scaleShape((0.25, 0.5), baseRes); // i spent hours on this math and idk why this value works but works holy fuck leave me alone
        borderIntroLeft.copy(borderLeft);
        borderIntroRight.copy(borderRight);

        for(int i = 0; i < borderIntroLeft.vertexSize(); i++) {
            borderIntroLeft.setVertex(i, borderIntroLeft.getVertex(i) * IMG_SCALE_INTRO - offset);
            borderIntroRight.setVertex(i, borderIntroRight.getVertex(i) * IMG_SCALE_INTRO - offset);
        }
    }

    enum DGReadMode {
        DRM_NONE = -1,
        DRM_SPEAKER,
        DRM_AUTOTIME,
        DRM_AVATAR,
        DRM_DIR,
        DRM_MESSAGE,
        DRM_MENU,
        DRM_NEXT
    }

    String speaker;
    String avatar;
    bool dir;
    String message;
    String next;

    // Dialogue population
    void stageDialogue(bool start)
    {
        if(start) {
            let cv = CVar.findCVar("DIALOGUE_QUEUE");
            next = cv.getString();

            cv = CVar.findCVar("DIALOGUE_OPEN");
            let start = cv.getString();

            String lang = Stringtable.Localize(start);
            String av;
            int ds;
            [av, ds] = getStringTil(lang, 0, "|");
            populateDialogue("", av, lang.mid(ds, 1), true);
        }

        if(next.length() > 0) {
            let mode = DRM_NONE;

            dir = false;
            String lang = Stringtable.Localize(next);
            next = "";

            String build = "";
            let i = 0;
            String ch = lang.mid(i, 1);

            //for(int i = 0; i < lang.length(); i++) {

            switch(mode) {
                default:
                    break;
                case DRM_NONE:
                    if(ch == "@") {
                        mode = DRM_MENU;
                        break;
                    }
                    if(ch == "$") {
                        mode = DRM_AUTOTIME;
                        break;
                    }
                    mode = DRM_SPEAKER; // set the state to speaker, then fallthrough
                case DRM_SPEAKER:
                    [speaker, i] = getStringTil(lang, i, "|");
                    mode = DRM_AVATAR; // set the state to avatar, then fallthrough
                case DRM_AVATAR:
                    [avatar, i] = getStringTil(lang, i, "|");
                    mode = DRM_DIR; // yeah
                case DRM_DIR:
                    let dir = lang.mid(i, 1);
                    i += 2;
                    mode = DRM_MESSAGE;
                case DRM_MESSAGE:
                    [message, i] = getStringTil(lang, i, "$");
                    next = lang.mid(i-1, 100);
                    mode = DRM_NONE;
                    break;
                case DRM_MENU:
                    break;
            }
            populateDialogue(speaker, avatar, dir);
            showMessage(message, dir);
        } else {
            changeState(DGS_NONE);
        }
    }

    string, int getStringTil(String s, int idx, string dest) {
        let end = s.indexOf(dest, idx);

        if(end >= s.length())
            end = s.length();

        if(end == -1)
            end = s.length();
        
        return s.mid(idx, end-idx), end+1;
    }

    void populateDialogue(String speaker, String avatar, String dir, bool skip = false) {

        DGReadMode dgs;
        NMImage lmSpeaker;
        NMLabel lmTag;

        if(dirIsRight(dir)) {
            dgs = DGS_RIGHT;
            lmSpeaker = rightSpeaker;
            lmTag = rightNameTag;
        } else {
            dgs = DGS_LEFT;
            lmSpeaker = leftSpeaker;
            lmTag = leftNameTag;
        }

        if(!skip)
            changeState(dgs);
        lmSpeaker.getElem().setImage(avatar);
        lmTag.getElem().setText(speaker);
    }

    void showMessage(String message, String dir) {
        
        int ds = -1;

        if(dirIsRight(dir)) {
            ds = 1;
        }

        let msg = DialogueMessage.create(message, baseRes.X-(160.0*2), (160.0, 710.0), MSG_BODY_SCALE, 1.0, ds);
        msg.pack(frame);
        dgMessages.push(msg);
        dgCurrent++;
    }

    bool dirIsRight(String dir) {
        return dir == "R";
    }

    Vector2 scaleShape(Vector2 a, Vector2 b) { return (a.x * b.x, a.y * b.y); }

    Vector2 scaleToOffset(Vector2 target, Vector2 current, double sc) {
        let diff = current - target;

        return (diff.x / target.x * sc, diff.y / target.y * sc);
    }

    /* might need these later
        Vector2 scaleShape(Vector2 a, Vector2 b) { return (a.x * b.x, a.y * b.y); }

    Vector2 getOffsFactors(AlignType align) {
		let top = align >> 4;
		let side = align - (top << 4) - 1;
		top--;

		let ret = (side * -0.5, top * -0.5);

		return ret;
	}
    */
}

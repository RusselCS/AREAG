const HP_SEG_MAX = 25;

class AREAGPlayerPawn : AREAGProtoPlayer {

    int iSelectedWep;
    int iPrevSelect;

    StateLabel slInterruptState;

    Array<SubWeapon> subs;
    Array<ToggleStateMap> toggles;
    Array<PlayerPassive> passives;
    Array<String> passiveClasses;

    bool isPushingBlock;
    AREAGPushBlock block;

    bool isCarryingBlock;
    Actor magBlock;
    String magBlockType;

    override void AREAGThink() {
        AREAGMoveThink();
    }

	override void AREAGTick() {

        AREAGHealthTick();
        AREAGMoveTick();
        AREAGStatusTick();

        if(CountInv("DroneFlag") > 0) {
            AREAGDroneTick();
        }

        if(iSelectedWep != iPrevSelect) {
            iPrevSelect = iSelectedWep;
            if(iSelectedWep > SWEP_NONE && iSelectedWep < subs.size())
            {
                // A_Log(subs[iSelectedWep].weaponName);
            }
        }

        for(int i = 0; i < passives.size(); i++) {
            if(passives[i]) {
                passives[i].passiveTick(AREAGPlayerPawn(self));
            } else {
                passives[i] = PlayerPassive(new(passiveClasses[i]));
            }
        }
    }

    void pushSubWeapon(SubWeapon wep) {
        subs.push(wep);
        if(iSelectedWep == SWEP_NONE) {
            iSelectedWep = 0;
        }
    }

    SubWeapon getCurrentSubweapon() {
        if(iSelectedWep == SWEP_NONE) {
            return null;
        }
        return subs[iSelectedWep];
    }

    SubWeapon selectNextSubweapon() {
        if(iSelectedWep == SWEP_NONE) {
            return null;
        } else {
            iSelectedWep = iSelectedWep + 1 >= subs.size() ? 0 : iSelectedWep + 1;
            return subs[iSelectedWep];
        }
    }

    SubWeapon selectPrevSubweapon() {
        if(iSelectedWep == SWEP_NONE) {
            return null;
        } else {
            iSelectedWep = iSelectedWep - 1 < 0 ? subs.size()-1 : iSelectedWep - 1;
            return subs[iSelectedWep];
        }
    }

    StateLabel getInterruptState() {
        return slInterruptState;
    }

    void setInterruptState(StateLabel target) {
        slInterruptState = target;
    }

    void clearInterruptState() {
        setInterruptState(null);
    }

    void pushToggleTrigger(ToggleStateMap map) {
        if(map) {
            toggles.push(map);
        }
    }

    StateLabel getToggleState() {
        for(int i = 0; i < toggles.size(); i++) {
            if(CountInv(toggles[i].getInventory()) > 0) {
                return toggles[i].getToggleState();
            }
        }
        return null;
    }

    void pushPassiveEffect(String clsName) {
        PlayerPassive pass = PlayerPassive(new(clsName));
        passives.push(pass);
        passiveClasses.push(clsName);
    }
    
    override void AREAGInit() {

		AREAGMoveInit();
		AREAGHealthInit();
        AREAGStatusInit();
		iSelectedWep = SWEP_NONE;
        slInterruptState = null;
	}

    void SetBlockPush(AREAGPushBlock blk) {
        if(blk) {
            block = blk;
            isPushingBlock = true;
        } else {
            block = null;
            isPushingBlock = false;
        }
    }

    AREAGPushBlock GetBlockPush() {
        return block;
    }

    void SetBlockGrab(Actor blk) {
        if(blk) {
            magBlock = blk;
            magBlockType = blk.getClassName();
            isCarryingBlock = true;
        } else {
            magBlock = null;
            isCarryingBlock = false;
        }
    }

    Actor GetBlockGrab() {
        return magBlock;
    }

    clearscope int CountMaxInv(class<Inventory> itemtype, int ptr_select = AAPTR_DEFAULT) const
	{
		let realself = GetPointer(ptr_select);
		if (realself == NULL || itemtype == NULL)
		{
			return 0;
		}
		else
		{
			return GetDefaultByType(itemtype).MaxAmount;
		}
	}
}

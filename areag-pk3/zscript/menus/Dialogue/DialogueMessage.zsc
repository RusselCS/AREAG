class DialogueObject ui
{
    double maxWidth;
    protected Vector2 pos;
    protected double scale;
    protected double alpha;
    protected DialogueObject parent;

    virtual void pack(ZFFrame frame) {}
    virtual void unpack() {}

    virtual bool drawer(double oldTime) { return true; }

    double getMaxWidth() { return self.maxWidth; }
    void setMaxWidth(double maxWidth) { self.maxWidth = maxWidth; }

    virtual void changePos(Vector2 delta) { self.pos += delta; }

    Vector2 getPos() { return self.pos; }
    virtual void setPos(Vector2 pos) { self.pos = pos; }

    double getScale() { return self.scale; }
    virtual void setScale(double scale) { self.scale = scale; }

    double getAlpha() { return self.alpha; }
    virtual void setAlpha(double alpha) { self.alpha = alpha; }

    DialogueObject getParent() { return self.parent; }
    void setParent(DialogueObject parent) { self.parent = parent; }

    virtual void next(bool remove, double amount) {}

    void config(DialogueObject parent, double maxWidth = 0.0, Vector2 pos = (0, 0), double scale = 1.0, double alpha = 1.0) {
        self.parent = parent;
        if(parent != null) {
            self.maxWidth = parent.getMaxWidth();
            self.pos = parent.getPos();
            self.scale = parent.getScale();
            self.alpha = parent.getAlpha();
        } else {
            self.maxWidth = maxWidth;
            self.pos = pos;
            self.scale = scale;
            self.alpha = alpha;
        }
    }

    static double deltaTime(double oldTime) { return double(MSTime() - oldTime) / 1000.0; }
}

class DialogueMessage : DialogueObject
{
    Array<DialogueLine> lines;
    String message; // message with formatting text
    int lineQueue;
    int lineMax;
    int destMax;
    int hiddenLines;
    double lineFeedDelay;
    bool finished;
    bool typing;

    static DialogueMessage create(String message, double maxWidth, Vector2 pos, double scale, double alpha) {
        let ret = new("DialogueMessage");

        ret.setMessage(message);
        ret.setMaxWidth(maxWidth);
        ret.setPos(pos);
        ret.setScale(scale);
        ret.setAlpha(alpha);
        ret.populate();

        return ret;
    }

    override void changePos(Vector2 delta) {
        self.pos += delta;
        for(int i = 0; i < lines.size(); i++) {
            lines[i].changePos(delta);
        }
    }

    void populate() {
        DialogueLine.populateLines(message, self, lines);
        if(lines.size() > 0) {
            lineQueue = 1;
            lineMax = min(lines.size(), 2);
            hiddenLines = 0;
            destMax = lineMax;
            finished = false;
            typing = true;
        }
    }

    String getMessage() { return self.message; }
    void setMessage(String message) { self.message = message; }

    override void pack(ZFFrame frame) {
        for(int i = 0; i < lines.size(); i++) {
            lines[i].pack(frame);
        }
    }

    override void unpack() {
        for(int i = 0; i < lines.size(); i++) {
            lines[i].unpack();
        }
    }

    void puke() {
        for(int i = 0; i < lines.size(); i++) {
            lines[i].puke();
        }
    }

    override bool drawer(double oldTime) {
        let addLine = true;

        for(int i = 0; i < lineQueue && i < lineMax; i++) {
            addLine = addLine && lines[i].drawer(oldTime);
        }

        if(lineFeedDelay > 0.0) {
            lineFeedDelay -= deltaTime(oldTime);
        } else if(addLine) {
            if(lineMax >= lines.size()) {
                finished = true;
            }

            if(lineQueue < lineMax) {
                lineQueue++;
            } else {
                if(lineMax < destMax) {
                    lineMax++;
                    dismissFirstLine();
                } else {
                    typing = false;
                }
            }
        }

        return true;
    }

    void skipTyping() {
        while(lineMax < destMax) {
            lineMax++;
            dismissFirstLine();
        }
        lineQueue = lineMax;
        lineFeedDelay = 0.0;

        for(int i = 0; i < lineMax; i++) {
            lines[i].skipTyping();
        }
    }

    bool isFinished() {
        return finished;
    }

    bool isTyping() {
        return typing;
    }

    double offsetAmount;

    override void next(bool remove, double amount) {
        offsetAmount = amount;
        typing = true;
        dismissFirstLine();
        lineMax = min(lineMax+1, lines.size());
        destMax = min(destMax+2, lines.size());
    }

    void dismissFirstLine() {
        let b = true;
        changePos((0, offsetAmount));
        for(int i = hiddenLines; i < lines.size(); i++) {
            lines[i].next(b, offsetAmount);
            b = false;
        }
        hiddenLines++;
        lineFeedDelay = 0.2;
    }

    void dismiss(double amount) {
        changePos((amount, 0));
        for(int i = 0; i < lines.size(); i++) {
            lines[i].dismiss();
        }
    }
}

class DialogueLine : DialogueObject
{
    Array<DialogueChar> chars;
    int charQueue;
    ZFFrame frame;
    double delayTime;

    static void populateLines(String message, DialogueObject parent, out Array<DialogueLine> lines) {
        // this is where the lines are broken apart
        let format = new("DialogueCharTemplate");
        format.setFont("DIAGFONT");
        format.setAvatar("");
        format.setDelay(0);
        format.setType(DCT_NORMAL);
        format.setEffect(DCE_NORMAL);
        format.setItalic(false);
        format.setBold(false);
        format.setUnderline(false);

        DialogueLine line = null;
        let newLine = true;
        String currentWord = "";
        Array<DialogueCharTemplate> wordFormats;
        int lastLen = 0;
        Vector2 linePos = (0, 0);
        let fnt = format.getFont();

        for(int i = 0; i < message.length(); i++) {
            let chr = message.mid(i, 1);

            if(newLine) {
                if(line != null) {
                    lines.push(line);
                    linePos += (-linePos.x, fnt.getHeight() * line.getScale());
                }
                line = new("DialogueLine");
                line.config(parent);
                line.charQueue = -1;
                lastLen = 0;
                newLine = false;
            }

            let newWord = false;
            
            if(chr == "#") { // delay text
                if(format.getDelay() != 0) {
                    format.setDelay(0);
                } else {
                    String time;
                    [time, i] = getStringTil(message, i+1, ":");
                    format.setDelay(time.toDouble());
                }
            } else if(chr == "|") { // type-on effect
                if(format.getType() != DCT_NORMAL) {
                    format.setType(DCT_NORMAL);
                } else {
                    String fx;
                    [fx, i] = getStringTil(message, i+1, ":");
                    fx = fx.makeUpper();
                    if(fx == "E") {
                        format.setType(DCT_EXPLODE);
                    } else if(fx == "F") {
                        format.setType(DCT_FADE);
                    }
                }
            } else if(chr == "~") { // passive effect
                if(format.getEffect() != DCE_NORMAL) {
                    format.setEffect(DCE_NORMAL);
                } else {
                    String fx;
                    [fx, i] = getStringTil(message, i+1, ":");
                    fx = fx.makeUpper();
                    if(fx == "S") {
                        format.setEffect(DCE_SHAKE);
                    } else if(fx == "W") {
                        format.setEffect(DCE_WAVE);
                    } else if(fx == "G") {
                        format.setEffect(DCE_GHOST);
                    }
                }
            } else 
            if(chr == "\n") {
                newWord = true;
                newLine = true;
            } else if(chr == " " || chr == "-") {
                currentWord.appendFormat("%s", chr);
                wordFormats.push(format.dupe());
                newWord = true;
            } else {
                currentWord.appendFormat("%s", chr);
                wordFormats.push(format.dupe());
            }

            if((fnt.stringWidth(currentWord) * line.getScale()) + lastLen > line.getMaxWidth()) {
                newLine = true;
            }

            if(newWord) {
                line.addChars(currentWord, wordFormats, linePos);
                let diff = fnt.stringWidth(currentWord) * line.getScale();
                lastLen += diff;
                linePos += (diff, 0);
                currentWord = "";
                wordFormats.clear();
            }
        }
        
        if(line != null) {
            line.addChars(currentWord, wordFormats, linePos);
            lines.push(line);
        }
    }

    override void changePos(Vector2 delta) {
        self.pos += delta;
        for(int i = 0; i < chars.size(); i++) {
            chars[i].changePos(delta);
        }
    }

    void skipTyping() {
        charQueue = chars.size()-1;
        for(int i = 0; i < chars.size(); i++) {
            if(!chars[i].isPacked()) {
                chars[i].pack(frame);
            }
            chars[i].skipTyping();
        }
    }

    static string, int getStringTil(String s, int idx, string dest) {
        let end = s.indexOf(dest, idx);

        if(end >= s.length())
            end = s.length();

        if(end == -1)
            end = s.length();
        
        return s.mid(idx, end-idx), end;
    }

    void addChars(String word, Array<DialogueCharTemplate> templates, Vector2 linePos) {
        let offs = (0, 0);
        for(int i = 0; i < word.length(); i++) {
            let chr = word.mid(i, 1);
            chars.push(DialogueChar.create(chr, self, linePos + offs, templates[i]));
            offs += (templates[i].getFont().stringWidth(chr) * scale, 0);
        }
    }

    override void pack(ZFFrame frame) {
        self.frame = frame;
    }

    override void unpack() {
        for(int i = 0; i < chars.size(); i++) {
            chars[i].unpack();
        }
    }

    String toString() {
        let ret = "";
        for(int i = 0; i < chars.size(); i++) {
            let chr = chars[i].getChar();
            ret.appendFormat("%s", chr);
        }
        return ret;
    }

    void puke() {
        console.printf("%s", toString());
    }

    override bool drawer(double oldTime) {
        if(charQueue == -1) {
            delayTime = chars[0].getFormat().getDelay();
            charQueue++;
        } else {
            for(int i = 0; i < charQueue; i++) {
                chars[i].drawer(oldTime);
            }
            
            let dTime = double(MSTime() - oldTime) / 1000.0;
            if(delayTime > 0.0) {
                delayTime -= dTime;
            } else {
                if(charQueue < chars.size()) {
                    chars[charQueue].pack(frame);
                    charQueue++;
                    if(charQueue < chars.size()) {
                        delayTime = chars[charQueue].getFormat().getDelay();
                    }
                } else {
                    return true;
                }
            }
        }
        return false;
    }

    override void next(bool remove, double amount) {
        for(int i = 0; i < chars.size(); i++) {
            chars[i].next(remove, amount);
        }
    }

    void dismiss() {
        for(int i = 0; i < chars.size(); i++) {
            chars[i].next(true, 0.0);
        }
    }
}

class DialogueChar : DialogueObject
{
    NMLabel label;
    DialogueCharTemplate format;
    String chr;
    bool packed;
    int dismissState;

    static DialogueChar create(String chr, DialogueObject parent, Vector2 offs, DialogueCharTemplate format) {
        let ret = new("DialogueChar");

        ret.config(parent);

        let fnt = format.getFont();
        let size = (fnt.stringWidth(chr), fnt.getHeight()) * ret.getScale();
        ret.setPos(parent.getPos() + offs);

        let label = NMLabel.create(ZFLabel.create(ret.getPos(), size, chr, fnt:fnt, textScale: ret.getScale()), DialogueMenu.UPDATE_SPEED);

        ret.setLabel(label);
        ret.setFormat(format);
        ret.setChar(chr);
        ret.init();
        return ret;
    }

    NMLabel getLabel() { return self.label; }
    void setLabel(NMLabel label) { self.label = label; }

    DialogueCharTemplate getFormat() { return self.format; }
    void setFormat(DialogueCharTemplate format) { self.format = format; }

    String getChar() { return self.chr; }
    void setChar(String chr) { self.chr = chr; }

    bool isPacked() {
        return packed;
    }

    void skipTyping() {
        label.setPos(label.getTPos());
        label.setAlpha(label.getTAlpha());
    }

    void init() {
        packed = false;
        dismissState = 0;
    }

    override void changePos(Vector2 delta) {
        self.pos += delta;
        label.setTPos(pos);
    }

    override void pack(ZFFrame frame)  {
        packed = true;
        label.setPos(label.getTPos());
        label.pack(frame);
    }

    override void unpack() {
        packed = false;
        label.unpack();
    }

    override bool drawer(double oldTime) {
        if(packed) {
            label.drawer();
            if(dismissState == 1) {
                if(label.getAlpha() <= 0.0) {
                    dismissState = 2;
                    unpack();
                }
            }
            let effect = format.getEffect();
            let effectRange = 8.0;
            let dTime = double(MSTime() - oldTime) / 1000.0;
            switch(effect) {
                default:
                    label.setTPos(pos);
                    break;
                case DCE_SHAKE:
                    label.setTPos(pos + (frandom(-1.0, 1.0), frandom(-1.0, 1.0) * effectRange/2));
                    break;
                case DCE_WAVE:
                    label.setTPos(pos + (0, sin(pos.X - MSTime() / 2) * effectRange));
                    break;
                case DCE_GHOST:
                    break;
            }
        }
        return true;
    }

    override void next(bool remove, double amount) {
        if(remove)
            label.setTAlpha(0.0);
    }
}

// will likely contain all the format types
class DialogueCharTemplate ui
{
    Font fnt;
    Font getFont() { return self.fnt; }
    void setFont(Font fnt) { self.fnt = fnt; }

    String avatar;
    String getAvatar() { return self.avatar; }
    void setAvatar(String avatar) { self.avatar = avatar; }

    double delay;
    double getDelay() { return self.delay; }
    void setDelay(double delay) { self.delay = delay; }

    DialogueCharType type;
    DialogueCharType getType() { return self.type; }
    void setType(DialogueCharType type) { self.type = type; }

    DialogueCharEffect effect;
    DialogueCharEffect getEffect() { return self.effect; }
    void setEffect(DialogueCharEffect effect) { self.effect = effect; }

    bool italic;
    bool getItalic() { return self.italic; }
    void setItalic(bool italic) { self.italic = italic; }

    bool bold;
    bool getBold() { return self.bold; }
    void setBold(bool bold) { self.bold = bold; }

    bool underline;
    bool getUnderline() { return self.underline; }
    void setUnderline(bool underline) { self.underline = underline; }

    DialogueCharTemplate dupe() {
        let ret = new("DialogueCharTemplate");

        ret.copy(self);

        return ret;
    }

    static DialogueCharTemplate create(Font fnt = "SMALLFONT", String avatar = "", double delay = 0, DialogueCharType type = DCT_NORMAL, DialogueCharEffect effect = DCE_NORMAL, bool italic = false, bool bold = false, bool underline = false) {
        let ret = new("DialogueCharTemplate");

        ret.setFont(fnt);
        ret.setAvatar(avatar);
        ret.setDelay(delay);
        ret.setType(type);
        ret.setEffect(effect);
        ret.setItalic(italic);
        ret.setBold(bold);
        ret.setUnderline(underline);

        return ret;
    }

    void copy(DialogueCharTemplate template) {
        self.setFont(template.getFont());
        self.setAvatar(template.getAvatar());
        self.setDelay(template.getDelay());
        self.setType(template.getType());
        self.setEffect(template.getEffect());
        self.setItalic(template.getItalic());
        self.setBold(template.getBold());
        self.setUnderline(template.getUnderline());
    }
}

enum DialogueCharType
{
    DCT_NORMAL,
    DCT_EXPLODE,
    DCT_FADE
}

enum DialogueCharEffect
{
    DCE_NORMAL,
    DCE_SHAKE,
    DCE_WAVE,
    DCE_GHOST
}

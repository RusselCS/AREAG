const SUB_KNIFE = 0;
const SUB_DYNAMITE = 1;

const HEALTH_MAX = -1;

const MAP_TABLET_WRAP = 100;

const BT_SUBNEXT = BT_USER1;
const BT_SUBPREV = BT_USER2;

enum PickupTypes {
	PICKTYPE_ARTIFICE,
	PICKTYPE_WEAPON,
	PICKTYPE_SUBWEAPON,
	PICKTYPE_TREASURE
}

enum UpgradeTypes {
	PICKMSG_GEAR,
	PICKMSG_STEAM,
	PICKMSG_KNIFE,
	PICKMSG_HEALTHUP,
	PICKMSG_DYNAMITE,
	PICKMSG_NOVAPACK,
	PICKMSG_SPIDERDRONE,
	PICKMSG_BEEDRONE,
	PICKMSG_STEELWHIP,
    PICKMSG_TRIBALSHIELD,
    PICKMSG_RUBYKEY,
    PICKMSG_COBALTKEY,
    PICKMSG_PERIDOTKEY,
    PICKMSG_GOLDKEY,
	PICKMSG_RITUALHORN,
	PICKMSG_GRAVITYGLOVES,
	PICKMSG_SEEDPOD
}

// BASIC ACTORS //
class Once : Inventory
{
    Default
    {
        inventory.amount 1;
        inventory.maxamount 1;
    }
}

class Counter : Inventory
{
    Default
    {
        inventory.amount 1;
        inventory.maxamount 65536;
    }
}

class BasicEffect : BasicActor
{
    Default
    {
        PROJECTILE;
        +NOINTERACTION;
        +THRUACTORS;
        +NOGRAVITY;
		+DONTSPLASH;
        renderstyle "translucent";
        alpha 1.0;
        height 1;
        radius 1;
    }

	int m_basicEffectFlags;
	flagdef MATCHTRACERSCALE: m_basicEffectFlags, 0;

	double rotationSpeed;
	double rollSpeed;
	double pitchSpeed;

	property RotationSpeed: rotationSpeed;
	property RollSpeed: rollSpeed;
	property PitchSpeed: pitchSpeed;

	override void Tick() {
		super.Tick();
		if(bMATCHTRACERSCALE && tracer) {
			if(scale.x != tracer.scale.x || scale.y != tracer.scale.y) {
				A_SetScale(tracer.scale.x, tracer.scale.y);
			}
		}
	}
}

class ZSCStoneBody : BasicActor
{
    override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle) {
        int dmg = super.DamageMobj(inflictor, source, min(damage, 1), mod, flags, angle);
        return dmg;
    }
}

class BasicFastProjectile : FastProjectile
{
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_JumpIf(true, "SpawnLoop");
		goto SpawnLoop;
	SpawnLoop:
		TNT1 A 0;
		stop;
	}
}

class BasicProjectile : BasicActor
{
	Default
	{
		PROJECTILE;
	}
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_JumpIf(true, "SpawnLoop");
		goto SpawnLoop;
	SpawnLoop:
		TNT1 A 0;
		stop;
	}
}

class PowerTime15 : PowerUp {
	Default
	{
		powerup.duration 15;
	}
}

const RADIUS_OFFS = 1.4142;

mixin class AREAG_Common
{
	// Returns -1 if x is even, 1 if odd
	static int SignModTwo(int x) {
		if(x % 2 == 0)  {
			return -1;
		} else {
			return 1;
		}
	}

	// Returns -1 if x < 0, 1 if x > 0, or 0 if x = 0
	static int SignFromInt(int x) {
		if(x < 0) {
			return -1;
		}
		if(x > 0) {
			return 1;
		}
		return 0;
	}

	// returns a decimal between -x and x
	static double fRandRange(float x) {
		return frandom(-x, x);
	}

	static double getCvarFloat(string cv)
	{
		return CVar.findCVar(cv).getFloat();
	}

	static bool getCvarBool(string cv)
	{
		let res = CVar.findCVar(cv);

		if(res) {
			return res.getBool();
		}
		return false;
	}

	static int getCvarInt(string cv)
	{
		let res = CVar.findCVar(cv);

		if(res) {
			return res.getInt();
		}
		return -1;
	}

	static bool checkPressed(int button, int buttons, int oldButtons)
    {
        if((buttons & button) && !(oldButtons & button))
        {
            return true;
        }
        return false;
    }

    static bool checkReleased(int button, int buttons, int oldButtons)
    {
        if(!(buttons & button) && (oldButtons & button))
        {
            return true;
        }
        return false;
    }

    static double Lerp(double a, double b, double t)
	{
		return (1 - t) * a + t * b;
	}

    static bool collidingBoxes(Actor a, Actor b, double rad) {
        double diffX = abs(a.pos.x - b.pos.x) - rad;
        double diffY = abs(a.pos.y - b.pos.y) - rad;

        return diffX <= 0 && diffY <= 0;
    }

	static double roundToNearest(double x, double y) {
		double md = x % y;

		if(md < y / 2) {
			return x - md;
		} else {
			return x - md + y;
		}
	}

	static double ceilingToNearest(double x, double y) {
		double md = x % y;

		if(md != 0.0) {
			return x - md + y;
		}
		return x;
	}
}

// DEBUG FUNCTIONS
class HitboxParticle : BasicEffect
{
    Default
    {
        +FORCEXYBILLBOARD;
        translation "0:255=104:104";
    }

    States
    {
    Spawn:
        CHWP BB 1 bright;
        wait;
    }
}

class BasicActor : Actor
{
	mixin AREAG_Common;

	Default
	{
		+ROLLSPRITE;
		+ROLLCENTER;
	}

	int m_basicActorFlags;

	flagdef SHOWHITBOX: m_basicActorFlags, 0;
	flagdef DIEWITHTARGET: m_basicActorFlags, 1;
	flagdef DIEWITHTRACER: m_basicActorFlags, 2;
	flagdef DIEWITHMASTER: m_basicActorFlags, 3;

	bool bToggleHitbox;
	Array<Actor> items;

    bool hasDied;

	override void PostBeginPlay() {
		Super.PostBeginPlay();
		BasicInit();
	}

    override void Tick() {
        Super.Tick();
		if(!IsFrozen() || bNOTIMEFREEZE) {
			BasicTick();

			if(!hasDied) {
				if((bDIEWITHTARGET && !target) ||
				   (bDIEWITHTRACER && !tracer) ||
				   (bDIEWITHMASTER && !master)) {
						Die(self, self);
				}
			}
			
		}
		updateHitbox();
    }

	override void Die(Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath) {
        hasDied = true;
        super.Die(source, inflictor, dmgflags, MeansOfDeath);
    }

	override void OnDestroy() {
		Super.OnDestroy();
		BasicDestroy();
		destroyHitbox();
	}

	virtual void BasicInit() {}
	virtual void BasicTick() {}
	virtual void BasicDestroy() {}

	void createHitbox() {
		for(int i = 0; i < radius; i+=2) {
			addToItems("HitboxParticle", radius, i, 1);
			addToItems("HitboxParticle", radius, -i, 1);
			addToItems("HitboxParticle", -radius, i, 1);
			addToItems("HitboxParticle", -radius, -i, 1);
			addToItems("HitboxParticle", i, radius, 1);
			addToItems("HitboxParticle", -i, radius, 1);
			addToItems("HitboxParticle", i, -radius, 1);
			addToItems("HitboxParticle", -i, -radius, 1);

			addToItems("HitboxParticle", radius, i, height);
			addToItems("HitboxParticle", radius, -i, height);
			addToItems("HitboxParticle", -radius, i, height);
			addToItems("HitboxParticle", -radius, -i, height);
			addToItems("HitboxParticle", i, radius, height);
			addToItems("HitboxParticle", -i, radius, height);
			addToItems("HitboxParticle", i, -radius, height);
			addToItems("HitboxParticle", -i, -radius, height);
		}

		for(int i = 1; i <= height; i+=2) {
			addToItems("HitboxParticle", radius, radius, i);
			addToItems("HitboxParticle", radius, -radius, i);
			addToItems("HitboxParticle", -radius, radius, i);
			addToItems("HitboxParticle", -radius, -radius, i);
		}
	}

	void updateHitbox() {

		if(bSHOWHITBOX || getCvarBool("db_viewhitboxes")) {
			if(!bToggleHitbox) {
				bToggleHitbox = true;
				createHitbox();
			}
		} else {
			if(bToggleHitbox) {
				bToggleHitbox = false;
				destroyHitbox();
			}
		}

		if(bToggleHitbox) {
			for(int i = 0; i < items.size(); i++) {
				items[i].A_Warp(AAPTR_MASTER, items[i].args[0], items[i].args[1], items[i].args[2], 0, WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE|WARPF_ABSOLUTEOFFSET);
			}
		}
	}

	void destroyHitbox() {
		for(int i = 0; i < items.size(); i++) {
			items[i].Destroy();
		}
		items.clear();
	}

	void addToItems(String item, int posx, int posy, int posz) {
		bool success;
		Actor act;

		[success, act] = A_SpawnItemEx(item, posx, posy, posz, 0, 0, 0, 0, SXF_SETMASTER);
		act.args[0] = posx;
		act.args[1] = posy;
		act.args[2] = posz;
		items.push(act);
	}

	action BasicEffect A_SpawnBasicEffect(string effect, double posx = 0, double posy = 0, double posz = 0, double velx = 0, double vely = 0, double velz = 0, double ang = 0, int flags = 0) {
		bool b;
		Actor fx;
		[b, fx] = A_SpawnItemEx(effect, posx, posy, posz, velx, vely, velz, ang, flags);
		BasicEffect ret = BasicEffect(fx);
		return ret;
	}

	action State A_CheckFooting(StateLabel where) {
		if(pos.z ~== floorz || bONMOBJ || bMBFBOUNCER) {
			return ResolveState(where);
		}
		return ResolveState(null);
	}

	bool XYLineTrace(double x, double y, double z, int flags = 0, double offsetforward = 0, double offsetside = 0) {
		
		double ang = VectorAngle(x, y);
		if(flags & XYLF_RELATIVE) {
			ang += angle;
		}

		if(flags & XYLF_ADDRADIUS) {
			let radiusMod = radius * RADIUS_OFFS;
			let radModX = SignFromInt(x) * radiusMod;
			let radModY = SignFromInt(y) * radiusMod;

			x += radModX;
			y += radModY;
		}

		double dist = sqrt(x * x + y * y);
		
		FLineTraceData deets;
		let ret = LineTrace(ang, dist, 0, TRF_SOLIDACTORS|TRF_THRUHITSCAN|TRF_BLOCKSELF, z, offsetforward, offsetside, deets);
		A_SpawnItemEx("WhipPuff", deets.HitLocation.x-pos.x, deets.HitLocation.y-pos.y, deets.HitLocation.z-pos.z, 0, 0, 0, 0, SXF_ABSOLUTEPOSITION);

		//A_Log(String.format("Angle: %f // In Dist: %f // Out Dist: %f", ang, dist, deets.distance));

		return ret;
	}

	action void A_StopXY() {
		A_ChangeVelocity(0, 0, vel.z, CVF_REPLACE);
	}
}

enum EXYLineTraceFlags
{
	XYLF_RELATIVE = 1,
	XYLF_ADDRADIUS = 2,
};

class BasicActionProp : BasicActor
{
	Default
	{
		+USESPECIAL;
		Activation THINGSPEC_TriggerActs|THINGSPEC_Switch;
	}

	override void Activate(Actor activator) {
		if(ActivateConditon())
			BasicActivate(activator);
	}

	virtual bool ActivateConditon() {
		return true;
	}
	virtual void BasicActivate(Actor activator) {}
}

class HitboxDebug : BasicActor {}

// MOVEMENT FLAGS //
class OnGround : Once {}
class JumpCancel : Once {}
class HeadUnderwater : Once {}
class LegsUnderwater : Once {}

class NoItem : BasicInventory {}

class MenuFreezer : Once {}
class TimeFreezer : PowerTimeFreezerSound
{
	Default
	{
		powerup.duration 0x7ffffff;
	}
}

class LevelNumTracker : Counter {}

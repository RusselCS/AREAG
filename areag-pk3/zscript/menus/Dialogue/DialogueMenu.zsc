class DialogueHandler : ZFHandler {
    // A reference to the menu we want to modify - the menu has to set this
    // to itself.
    DialogueMenu menu;

    override void buttonClickCommand(ZFButton caller, String command) {
        // Check if the command matches the button's command.
        if (command == 'firstButtonClick') {
            // Add 50 to the menu's desired label X position.
            menu.desiredPosX += 50;
        } else if (command == 'secondButtonClick') {
            // Subtract 50 from the menu's desired label X position.
            menu.desiredPosX -= 50;
        }
    }
}

enum DialogueState {
    DGS_NONE = -1,
    DGS_LEFT,
    DGS_RIGHT
}

class DialogueMenu : ZFGenericMenu {
    // Store a reference to the frame now that we want to change it later.
    ZFFrame frame;

    // Dialogue state information
    int tick;
    int stateTick;
    int sframe;
    DialogueState lastState;
    DialogueState dgState;

    // Dialogue screen elements
    int bordersIdx;
    int nameBoxIdx;
    int leftSpeakerIdx;
    int rightSpeakerIdx;
    int textBoxIdx;
    int leftNameTagIdx;
    int rightNameTagIdx;

    Array<NMElement> elems;

    // Where we want the frame to end up.
    double desiredPosX;

    Font textFont;
    Font nameFont;

    Vector2 imgCenter;
    Vector2 baseres;

    ShapeInfo borderIntroLeft;
    ShapeInfo borderIntroRight;
    ShapeInfo borderLeft;
    ShapeInfo borderRight;
    NMShape borders;

    String next;

    const UPDATE_SPEED = 8.0;

    override void init(Menu parent) {

        tick = 0;
        stateTick = 0;
        sframe = 0;
        lastState = DGS_NONE;
        dgState = DGS_NONE;
        textFont = "DIAGFONT";
        nameFont = "AREAFONT";


        imgCenter = (350, 0);

        // This must be called to ensure that the menu is set up properly.
        Super.init(parent);
        // ZForms menus work by using a "virtual" resolution which means that
        // you only have to design the menu for this resolution.
        // Here we'll use a typical monitor resolution, but this can be anything,
        // even 320x200.
        baseRes = (1600, 900);
        setBaseResolution(baseRes);
        populateCoords();

        // Here we make a frame - it needs to be positioned right, and big enough
        // to contain the elements we want inside it.
        self.frame = ZFFrame.create(
            (0, 0),
            (baseRes.x, baseRes.y)
        );
        // Set the desired X position to the starting X position so it doesn't
        // instantly move.
        self.desiredPosX = self.frame.getPosX();
        frame.pack(mainFrame);

        leftSpeakerIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            imgCenter,
            (900, 900), // max scale 3
            image: "CLYSNORM",
            alignment: ZFElement.AlignType_BottomCenter
        ), UPDATE_SPEED));
        //elems[leftSpeakerIdx].myName = "leftSpeakerIdx";

        rightSpeakerIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            imgCenter,
            (900, 900),
            image: "ELDSNORM",
            alignment: ZFElement.AlignType_BottomCenter
        ), UPDATE_SPEED));
        //elems[rightSpeakerIdx].myName = "rightSpeakerIdx";

        borders = NMShape.create(ZFShape.create(
            (0, 0),
            baseRes,
            borderRight,
            "DG_OFRMX",
            ZFElement.AlignType_TopCenter
        ), UPDATE_SPEED);
        elems.push(borders);

        textBoxIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            // This argument controls the position - 50 pixels under the label.
            (  0, 0),
            // This argument controls the size. Here we match STARTAN2.
            (1600, 900),
            // The texture name.
            image: "DG_SPBOX",
            alignment: ZFElement.AlignType_TopCenter
        ), UPDATE_SPEED));
        //elems[textBoxIdx].myName = "textBoxIdx";

        // nameBoxIdx = elems.size();
        // elems.push(NMImage.create(ZFImage.create(
        //     (  0, 0),
        //     (1600, 900),
        //     alignment: ZFElement.AlignType_TopCenter
        // ), UPDATE_SPEED));

        leftNameTagIdx = elems.size();
        elems.push(NMLabel.create(ZFLabel.create(
            (NAMETAG_X, NAMETAG_Y),
            (1600, 900),
            text: "Clyde",
            fnt: nameFont,
            alignment: ZFElement.AlignType_BottomLeft,
            textScale: NAMETAG_SCALE
        ), UPDATE_SPEED));
        //elems[leftNameTagIdx].myName = "leftNameTagIdx";

        rightNameTagIdx = elems.size();
        elems.push(NMLabel.create(ZFLabel.create(
            (-NAMETAG_X, NAMETAG_Y),
            (1600, 900),
            text: "Village Elder",
            fnt: nameFont,
            alignment: ZFElement.AlignType_BottomRight,
            textScale: NAMETAG_SCALE
        ), UPDATE_SPEED));
        //elems[rightNameTagIdx].myName = "rightNameTagIdx";

        for(int i = 0; i < elems.size(); i++) {
            elems[i].pack(frame);
        }

        stageDialogue();
        changeState(DGS_RIGHT);
    }

    const NAMETAG_X = 100;
    const NAMETAG_Y = -212;
    const NAMETAG_SCALE = 1.1;

    const NAMETAG_X_SCROLL = 200;

    const SPEAKER_SCALE_ACTIVE = 1.500;
    const SPEAKER_SCALE_INACTIVE = 1.000;

    const SPEAKER_POS_ACTIVE = -171;
    const SPEAKER_POS_INACTIVE = -671;

    const IMG_SCALE_INTRO = 1.5;

    override void drawer() {
        for(int i = 0; i < elems.size(); i++) {
            elems[i].drawer();
        }

        super.drawer();
    }

    int stateTime()
    {
        return tick - stateTick;
    }

    void swapSides()
    {
        if(dgState == DGS_LEFT || dgState == DGS_RIGHT)
        {
            if(dgState == DGS_LEFT)
                changeState(DGS_RIGHT);
            else
                changeState(DGS_LEFT);
        }
    }

    void changeState(DialogueState st)
    {
        if(st != dgState) {
            sframe = 0;
            stateTick = tick;
            lastState = dgState;
            dgState = st;
        }

        let activePos = (SPEAKER_POS_ACTIVE, 0);
        let inactivePos = (SPEAKER_POS_INACTIVE, 0);

        let activeScale = (SPEAKER_SCALE_ACTIVE, SPEAKER_SCALE_ACTIVE);
        let inactiveScale = (SPEAKER_SCALE_INACTIVE, SPEAKER_SCALE_INACTIVE);

        if(dgState != DGS_NONE && lastState == DGS_NONE) { // intro
            elems[textBoxIdx].setScale((1.0, 1.0) * IMG_SCALE_INTRO);
            elems[textBoxIdx].setTScale((1.0, 1.0));
            elems[textBoxIdx].setAlpha(0.0);
            elems[textBoxIdx].setTAlpha(1.0);

            switch(dgState) {
                case DGS_RIGHT:
                    elems[leftSpeakerIdx].setScale(inactiveScale * IMG_SCALE_INTRO);
                    elems[leftSpeakerIdx].setTScale(inactiveScale);
                    elems[leftSpeakerIdx].setAlpha(0.0);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setPos(imgCenter + IMG_SCALE_INTRO * inactivePos);
                    elems[leftSpeakerIdx].setTPos(imgCenter + inactivePos);

                    elems[leftNameTagIdx].setAlpha(0.0);
                    elems[leftNameTagIdx].setTAlpha(0.0);
                    elems[leftNameTagIdx].setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    elems[rightSpeakerIdx].setScale(activeScale * IMG_SCALE_INTRO);
                    elems[rightSpeakerIdx].setTScale(activeScale);
                    elems[rightSpeakerIdx].setAlpha(0.0);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setPos(imgCenter - IMG_SCALE_INTRO * activePos);
                    elems[rightSpeakerIdx].setTPos(imgCenter - activePos);

                    elems[rightNameTagIdx].setAlpha(0.0);
                    elems[rightNameTagIdx].setTAlpha(1.0);
                    elems[rightNameTagIdx].setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y));

                    borders.setShape(borderIntroRight);
                    borders.setTShape(borderRight);
                    borders.setAlpha(0.0);
                    borders.setTAlpha(1.0);
                    break;
                case DGS_LEFT:
                    elems[leftSpeakerIdx].setScale(activeScale * IMG_SCALE_INTRO);
                    elems[leftSpeakerIdx].setTScale(activeScale);
                    elems[leftSpeakerIdx].setAlpha(0.0);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setPos(imgCenter + IMG_SCALE_INTRO * activePos);
                    elems[leftSpeakerIdx].setTPos(imgCenter + activePos);

                    elems[leftNameTagIdx].setAlpha(0.0);
                    elems[leftNameTagIdx].setTAlpha(1.0);
                    elems[leftNameTagIdx].setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y));

                    elems[rightSpeakerIdx].setScale(inactiveScale * IMG_SCALE_INTRO);
                    elems[rightSpeakerIdx].setTScale(inactiveScale);
                    elems[rightSpeakerIdx].setAlpha(0.0);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setPos(imgCenter - IMG_SCALE_INTRO * inactivePos);
                    elems[rightSpeakerIdx].setTPos(imgCenter - inactivePos);

                    elems[rightNameTagIdx].setAlpha(0.0);
                    elems[rightNameTagIdx].setTAlpha(0.0);
                    elems[rightNameTagIdx].setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));

                    borders.setShape(borderIntroLeft);
                    borders.setTShape(borderLeft);
                    borders.setAlpha(0.0);
                    borders.setTAlpha(1.0);
                    break;
            }
        }

        if(dgState != DGS_NONE && lastState != DGS_NONE) { // swap sides
            switch(dgState) {
                case DGS_RIGHT:
                    elems[leftSpeakerIdx].setTScale(inactiveScale);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setTPos(imgCenter + inactivePos);

                    elems[leftNameTagIdx].setTAlpha(0.0);
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    elems[rightSpeakerIdx].setTScale(activeScale);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setTPos(imgCenter - activePos);

                    elems[rightNameTagIdx].setTAlpha(1.0);
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y));

                    borders.setTShape(borderRight);
                    break;
                case DGS_LEFT:
                    elems[leftSpeakerIdx].setTScale(activeScale);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setTPos(imgCenter + activePos);

                    elems[leftNameTagIdx].setTAlpha(1.0);
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y));

                    elems[rightSpeakerIdx].setTScale(inactiveScale);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setTPos(imgCenter - inactivePos);

                    elems[rightNameTagIdx].setTAlpha(0.0);
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));

                    borders.setTShape(borderLeft);
                    break;
            }
        }
    }

    override void ticker()
    {
        let st = stateTime();

        if(st > 70) {
            swapSides();
        }

        tick++;
    }

    // Population functions
    // Shape population
    void populateCoords()
    {
        borderLeft = ShapeInfo.create(baseRes);
        borderIntroLeft = ShapeInfo.create(baseRes);
        borderRight = ShapeInfo.create(baseRes);
        borderIntroRight = ShapeInfo.create(baseRes);

        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.660, -0.150));
        borderLeft.pushVC(( 0.700,  0.000));
        borderLeft.pushVC(( 1.000,  0.000));
        borderLeft.pushVC(( 1.000,  0.000));
        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.000,  0.000));
        borderLeft.pushVC(( 0.660, -0.150));
        borderLeft.pushVC(( 0.730,  0.320));
        borderLeft.pushVC(( 1.000,  0.240));
        borderLeft.pushVC(( 1.000,  0.240));
        borderLeft.pushVC(( 0.000,  1.000));
        borderLeft.pushVC(( 0.100,  1.000));
        borderLeft.pushVC(( 0.780,  1.000));
        borderLeft.pushVC(( 0.800,  1.000));
        borderLeft.pushVC(( 1.070,  1.000));
        borderLeft.pushVC(( 1.070,  1.000));

        borderLeft.pushTriangle((0, 1, 7));
        borderLeft.pushTriangle((0, 6, 7));
        borderLeft.pushTriangle((6, 7, 13));
        borderLeft.pushTriangle((6, 12, 13));
        borderLeft.pushTriangle((1, 2, 8));
        borderLeft.pushTriangle((1, 7, 8));
        borderLeft.pushTriangle((2, 3, 9));
        borderLeft.pushTriangle((2, 8, 9));
        borderLeft.pushTriangle((8, 9, 15));
        borderLeft.pushTriangle((8, 14, 15));
        borderLeft.pushTriangle((3, 4, 10));
        borderLeft.pushTriangle((3, 9, 10));
        borderLeft.pushTriangle((4, 5, 11));
        borderLeft.pushTriangle((4, 10, 11));
        borderLeft.pushTriangle((10, 11, 17));
        borderLeft.pushTriangle((10, 16, 17));
       

        borderRight.pushVC(( 0.000,  0.000));
        borderRight.pushVC(( 0.000,  0.000));
        borderRight.pushVC(( 0.300,  0.000));
        borderRight.pushVC(( 0.340, -0.150));
        borderRight.pushVC(( 0.340, -0.150));
        borderRight.pushVC(( 1.000,  0.000));
        borderRight.pushVC(( 0.000,  0.000));
        borderRight.pushVC(( 0.000,  0.240));
        borderRight.pushVC(( 0.270,  0.320));
        borderRight.pushVC(( 0.340, -0.150));
        borderRight.pushVC(( 1.000,  0.000));
        borderRight.pushVC(( 1.000,  0.000));
        borderRight.pushVC((-0.070,  1.000));
        borderRight.pushVC((-0.070,  1.000));
        borderRight.pushVC(( 0.200,  1.000));
        borderRight.pushVC(( 0.220,  1.000));
        borderRight.pushVC(( 0.900,  1.000));
        borderRight.pushVC(( 1.000,  1.000));

        borderRight.pushTriangle((0, 1, 7));
        borderRight.pushTriangle((0, 6, 7));
        borderRight.pushTriangle((6, 7, 13));
        borderRight.pushTriangle((6, 12, 13));
        borderRight.pushTriangle((1, 2, 8));
        borderRight.pushTriangle((1, 7, 8));
        borderRight.pushTriangle((2, 3, 9));
        borderRight.pushTriangle((2, 8, 9));
        borderRight.pushTriangle((8, 9, 15));
        borderRight.pushTriangle((8, 14, 15));
        borderRight.pushTriangle((3, 4, 10));
        borderRight.pushTriangle((3, 9, 10));
        borderRight.pushTriangle((4, 5, 11));
        borderRight.pushTriangle((4, 10, 11));
        borderRight.pushTriangle((10, 11, 17));
        borderRight.pushTriangle((10, 16, 17));

        let offset = scaleShape((0.25, 0.5), baseRes); // i spent hours on this math and idk why this value works but works holy fuck leave me alone
        borderIntroLeft.copy(borderLeft);
        borderIntroRight.copy(borderRight);
        
        let my = 0.0;
        let ny = 0.0;

        for(int i = 0; i < borderIntroLeft.vertexSize(); i++) {
            borderIntroLeft.setVertex(i, borderIntroLeft.getVertex(i) * IMG_SCALE_INTRO - offset);
            borderIntroRight.setVertex(i, borderIntroRight.getVertex(i) * IMG_SCALE_INTRO - offset);
            let vert = borderIntroRight.getVertex(i);
            my = max(vert.y, my);
            ny = min(vert.y, ny);
        }

        console.printf("MaxY: %f // MinY: %f // Diff: %f", my, ny, my-ny);
    }

    // Dialogue population
    void stageDialogue()
    {
        let cv = CVar.findCVar("DIALOGUE_QUEUE");
        String strIn = cv.getString();
        Console.printf(strIn);

        if(strIn.length() != 0) {
            String lang = Stringtable.Localize(strIn);

            //for(int i = 0; i < )
            Console.printf(lang);
        }
    }

    void populateDialogue(String who, String port, bool pos) {
        
    }

    Vector2 scaleShape(Vector2 a, Vector2 b) { return (a.x * b.x, a.y * b.y); }

    Vector2 scaleToOffset(Vector2 target, Vector2 current, double sc) {
        let diff = current - target;

        return (diff.x / target.x * sc, diff.y / target.y * sc);
    }

    /* might need these later
        Vector2 scaleShape(Vector2 a, Vector2 b) { return (a.x * b.x, a.y * b.y); }

    Vector2 getOffsFactors(AlignType align) {
		let top = align >> 4;
		let side = align - (top << 4) - 1;
		top--;

		let ret = (side * -0.5, top * -0.5);

		return ret;
	}
    */
}

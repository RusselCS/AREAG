class DialogueHandler : ZFHandler {
    // A reference to the menu we want to modify - the menu has to set this
    // to itself.
    DialogueMenu menu;

    override void buttonClickCommand(ZFButton caller, String command) {
        // Check if the command matches the button's command.
        if (command == 'firstButtonClick') {
            // Add 50 to the menu's desired label X position.
            menu.desiredPosX += 50;
        } else if (command == 'secondButtonClick') {
            // Subtract 50 from the menu's desired label X position.
            menu.desiredPosX -= 50;
        }
    }
}

enum DialogueState {
    DGS_NONE = -1,
    DGS_LEFT,
    DGS_RIGHT
}

class DialogueMenu : ZFGenericMenu {
    // Store a reference to the frame now that we want to change it later.
    ZFFrame frame;

    // Dialogue state information
    int tick;
    int stateTick;
    int sframe;
    DialogueState lastState;
    DialogueState dgState;

    // Dialogue screen elements
    int bordersIdx;
    int nameBoxIdx;
    int leftSpeakerIdx;
    int rightSpeakerIdx;
    int textBoxIdx;
    int leftNameTagIdx;
    int rightNameTagIdx;

    Array<NMElement> elems;

    // Where we want the frame to end up.
    double desiredPosX;

    Font textFont;
    Font nameFont;

    Vector2 imgCenter;

    String next;

    const UPDATE_SPEED = 8.0;

    override void init(Menu parent) {
        tick = 0;
        stateTick = 0;
        sframe = 0;
        lastState = DGS_NONE;
        dgState = DGS_NONE;
        textFont = "DIAGFONT";
        nameFont = "AREAFONT";

        imgCenter = (350, 0);

        // This must be called to ensure that the menu is set up properly.
        Super.init(parent);
        // ZForms menus work by using a "virtual" resolution which means that
        // you only have to design the menu for this resolution.
        // Here we'll use a typical monitor resolution, but this can be anything,
        // even 320x200.
        let baseRes = (1600, 900);
        setBaseResolution(baseRes);

        // Here we make a frame - it needs to be positioned right, and big enough
        // to contain the elements we want inside it.
        self.frame = ZFFrame.create(
            (0, 0),
            (baseRes.x, baseRes.y)
        );
        // Set the desired X position to the starting X position so it doesn't
        // instantly move.
        self.desiredPosX = self.frame.getPosX();
        frame.pack(mainFrame);

        leftSpeakerIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            imgCenter,
            (900, 900), // max scale 3
            image: "CLYSNORM",
            alignment: ZFElement.AlignType_BottomCenter
        ), UPDATE_SPEED));
        //elems[leftSpeakerIdx].myName = "leftSpeakerIdx";

        rightSpeakerIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            imgCenter,
            (900, 900),
            image: "ELDSNORM",
            alignment: ZFElement.AlignType_BottomCenter
        ), UPDATE_SPEED));
        //elems[rightSpeakerIdx].myName = "rightSpeakerIdx";

        // bordersIdx = elems.size();
        // elems.push(NMImage.create(ZFImage.create(
        //     // This argument controls the position - 50 pixels under the label.
        //     (  0, 0),
        //     // This argument controls the size. Here we match STARTAN2.
        //     (1600, 900),
        //     alignment: ZFElement.AlignType_BottomCenter
        // ), UPDATE_SPEED));

        textBoxIdx = elems.size();
        elems.push(NMImage.create(ZFImage.create(
            // This argument controls the position - 50 pixels under the label.
            (  0, 0),
            // This argument controls the size. Here we match STARTAN2.
            (1600, 900),
            // The texture name.
            image: "DG_SPBOX",
            alignment: ZFElement.AlignType_TopCenter
        ), UPDATE_SPEED));
        //elems[textBoxIdx].myName = "textBoxIdx";

        // nameBoxIdx = elems.size();
        // elems.push(NMImage.create(ZFImage.create(
        //     (  0, 0),
        //     (1600, 900),
        //     alignment: ZFElement.AlignType_TopCenter
        // ), UPDATE_SPEED));

        leftNameTagIdx = elems.size();
        elems.push(NMLabel.create(ZFLabel.create(
            (NAMETAG_X, NAMETAG_Y),
            (1600, 900),
            text: "Clyde",
            fnt: nameFont,
            alignment: ZFElement.AlignType_BottomLeft,
            textScale: NAMETAG_SCALE
        ), UPDATE_SPEED));
        //elems[leftNameTagIdx].myName = "leftNameTagIdx";

        rightNameTagIdx = elems.size();
        elems.push(NMLabel.create(ZFLabel.create(
            (-NAMETAG_X, NAMETAG_Y),
            (1600, 900),
            text: "Village Elder",
            fnt: nameFont,
            alignment: ZFElement.AlignType_BottomRight,
            textScale: NAMETAG_SCALE
        ), UPDATE_SPEED));
        //elems[rightNameTagIdx].myName = "rightNameTagIdx";

        for(int i = 0; i < elems.size(); i++) {
            elems[i].pack(frame);
        }

        stageDialogue();
        changeState(DGS_RIGHT);
    }

    static const String[] borderNames = {
        "DG_OFRM1",
        "DG_OFRM2",
        "DG_OFRM3",
        "DG_OFRM4",
        "DG_OFRM5"
    };

    static const String[] nameBoxNames = {
        "DG_NMBX1",
        "DG_NMBX2",
        "DG_NMBX3",
        "DG_NMBX4",
        "DG_NMBX5"
    };

    static const double[] speakScales = {
        1.000,
        1.125,
        1.250,
        1.375,
        1.500
    };

    static const double[] speakXs = {
        -171,
        -296,
        -421,
        -546,
        -671
    };

    const TICKS_PER_FRAME = 2;

    const NAMETAG_X = 100;
    const NAMETAG_Y = -212;
    const NAMETAG_SCALE = 1.1;

    const NAMETAG_X_SCROLL = 200;

    const SPEAKER_SCALE_ACTIVE = 1.500;
    const SPEAKER_SCALE_INACTIVE = 1.000;

    const SPEAKER_POS_ACTIVE = -171;
    const SPEAKER_POS_INACTIVE = -671;

    const IMG_SCALE_INTRO = 1.5;

    override void drawer() {
        for(int i = 0; i < elems.size(); i++) {
            elems[i].drawer();
        }

        super.drawer();
    }

    int stateTime()
    {
        return tick - stateTick;
    }

    void swapSides()
    {
        if(dgState == DGS_LEFT || dgState == DGS_RIGHT)
        {
            if(dgState == DGS_LEFT)
                changeState(DGS_RIGHT);
            else
                changeState(DGS_LEFT);
        }
    }

    void changeState(DialogueState st)
    {
        if(st != dgState) {
            sframe = 0;
            stateTick = tick;
            lastState = dgState;
            dgState = st;
        }

        let activePos = (SPEAKER_POS_ACTIVE, 0);
        let inactivePos = (SPEAKER_POS_INACTIVE, 0);

        let activeScale = (SPEAKER_SCALE_ACTIVE, SPEAKER_SCALE_ACTIVE);
        let inactiveScale = (SPEAKER_SCALE_INACTIVE, SPEAKER_SCALE_INACTIVE);

        if(dgState != DGS_NONE && lastState == DGS_NONE) { // intro
            elems[textBoxIdx].setScale((1.0, 1.0) * IMG_SCALE_INTRO);
            elems[textBoxIdx].setTScale((1.0, 1.0));
            elems[textBoxIdx].setAlpha(0.0);
            elems[textBoxIdx].setTAlpha(1.0);

            switch(dgState) {
                case DGS_RIGHT:
                    elems[leftSpeakerIdx].setScale(inactiveScale * IMG_SCALE_INTRO);
                    elems[leftSpeakerIdx].setTScale(inactiveScale);
                    elems[leftSpeakerIdx].setAlpha(0.0);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setPos(imgCenter + IMG_SCALE_INTRO * inactivePos);
                    elems[leftSpeakerIdx].setTPos(imgCenter + inactivePos);

                    elems[leftNameTagIdx].setAlpha(0.0);
                    elems[leftNameTagIdx].setTAlpha(0.0);
                    elems[leftNameTagIdx].setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    elems[rightSpeakerIdx].setScale(activeScale * IMG_SCALE_INTRO);
                    elems[rightSpeakerIdx].setTScale(activeScale);
                    elems[rightSpeakerIdx].setAlpha(0.0);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setPos(imgCenter - IMG_SCALE_INTRO * activePos);
                    elems[rightSpeakerIdx].setTPos(imgCenter - activePos);

                    elems[rightNameTagIdx].setAlpha(0.0);
                    elems[rightNameTagIdx].setTAlpha(1.0);
                    elems[rightNameTagIdx].setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y));
                    break;
                case DGS_LEFT:
                    elems[leftSpeakerIdx].setScale(activeScale * IMG_SCALE_INTRO);
                    elems[leftSpeakerIdx].setTScale(activeScale);
                    elems[leftSpeakerIdx].setAlpha(0.0);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setPos(imgCenter + IMG_SCALE_INTRO * activePos);
                    elems[leftSpeakerIdx].setTPos(imgCenter + activePos);

                    elems[leftNameTagIdx].setAlpha(0.0);
                    elems[leftNameTagIdx].setTAlpha(1.0);
                    elems[leftNameTagIdx].setPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y));

                    elems[rightSpeakerIdx].setScale(inactiveScale * IMG_SCALE_INTRO);
                    elems[rightSpeakerIdx].setTScale(inactiveScale);
                    elems[rightSpeakerIdx].setAlpha(0.0);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setPos(imgCenter - IMG_SCALE_INTRO * inactivePos);
                    elems[rightSpeakerIdx].setTPos(imgCenter - inactivePos);

                    elems[rightNameTagIdx].setAlpha(0.0);
                    elems[rightNameTagIdx].setTAlpha(0.0);
                    elems[rightNameTagIdx].setPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    break;
            }
        }

        if(dgState != DGS_NONE && lastState != DGS_NONE) { // swap sides
            switch(dgState) {
                case DGS_RIGHT:
                    elems[leftSpeakerIdx].setTScale(inactiveScale);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setTPos(imgCenter + inactivePos);

                    elems[leftNameTagIdx].setTAlpha(0.0);
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y) - (NAMETAG_X_SCROLL, 0));

                    elems[rightSpeakerIdx].setTScale(activeScale);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setTPos(imgCenter - activePos);

                    elems[rightNameTagIdx].setTAlpha(1.0);
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y));
                    break;
                case DGS_LEFT:
                    elems[leftSpeakerIdx].setTScale(activeScale);
                    elems[leftSpeakerIdx].setTAlpha(1.0);
                    elems[leftSpeakerIdx].setTPos(imgCenter + activePos);

                    elems[leftNameTagIdx].setTAlpha(1.0);
                    elems[leftNameTagIdx].setTPos((NAMETAG_X, NAMETAG_Y));

                    elems[rightSpeakerIdx].setTScale(inactiveScale);
                    elems[rightSpeakerIdx].setTAlpha(1.0);
                    elems[rightSpeakerIdx].setTPos(imgCenter - inactivePos);

                    elems[rightNameTagIdx].setTAlpha(0.0);
                    elems[rightNameTagIdx].setTPos((-NAMETAG_X, NAMETAG_Y) + (NAMETAG_X_SCROLL, 0));
                    break;
            }
        }
    }

    override void ticker()
    {
        let st = stateTime();

        if(st > 70) {
            swapSides();
        }

        tick++;
    }

    void stageDialogue()
    {
        String strIn = CVar.findCVar("DIALOGUE_QUEUE").getString();
        Console.printf(strIn);

        if(strIn.length() != 0) {
            String lang = Stringtable.Localize(strIn);
            Console.printf(lang);
        }
    }

    // LEGACY ==========================================================================================

    // override void ticker() {
        // int st = stateTime();
        // int animTime = borderNames.size() * TICKS_PER_FRAME;
        // int openTime = animTime / 2;

        // if(st <= animTime) {
            
        //     if(dgState != DGS_NONE && lastState != DGS_NONE) {
                
        //         let opct = 1.0 - double(st) / double(openTime);
        //         let ipct = 0.0 + double(st - openTime) / double(openTime);

        //         if(dgState == DGS_RIGHT) {
        //             leftNameTag.setAlpha(opct);
        //             rightNameTag.setAlpha(ipct);
        //         } else {
        //             leftNameTag.setAlpha(ipct);
        //             rightNameTag.setAlpha(opct);
        //         }

        //         if(tick % TICKS_PER_FRAME == 0) {
        //             let rframe = borderNames.size() - 1 - sframe;

        //             if(dgState == DGS_RIGHT)
        //             {
        //                 if(lastState != DGS_NONE) { // left to right
        //                     borders.setImage(borderNames[sframe]);
        //                     nameBox.setImage(nameBoxNames[sframe]);

        //                     // Left -> Right
        //                     // Left image slides left
        //                     leftSpeaker.setImageScale((speakScales[rframe], speakScales[rframe]));
        //                     leftSpeaker.setPos(imgCenter + (speakXs[sframe], 0));
        //                     // Right image slides right
        //                     rightSpeaker.setImageScale((speakScales[sframe], speakScales[sframe]));
        //                     rightSpeaker.setPos(imgCenter - (speakXs[rframe], 0));
        //                 }
        //             }

        //             if(dgState == DGS_LEFT)
        //             {
        //                 if(lastState != DGS_NONE) { // left to right
        //                     borders.setImage(borderNames[borderNames.size() - 1 - (sframe)]);
        //                     nameBox.setImage(nameBoxNames[nameBoxNames.size() - 1 - (sframe)]);

        //                     // Right -> Left
        //                     // Left image slides right
        //                     leftSpeaker.setImageScale((speakScales[sframe], speakScales[sframe]));
        //                     leftSpeaker.setPos(imgCenter + (speakXs[rframe], 0));
        //                     // Right image slides left
        //                     rightSpeaker.setImageScale((speakScales[rframe], speakScales[rframe]));
        //                     rightSpeaker.setPos(imgCenter - (speakXs[sframe], 0));
        //                 }
        //             }

        //             sframe++;
        //         } // every X frames check

        //     } else { // We can uncap the animation for opening/closing because those don't need to be hand-drawn.
        //         if(st <= openTime) {
        //             let findex = 0;
        //             let lindex = borderNames.size() - 1;

        //             let sStart = 1.5;
        //             let sTarget = 1.0;
        //             let sMove = (sStart - sTarget) / openTime;

        //             let curScale = sStart - sMove * st;
        //             let curAlpha = (1.0 / openTime) * st;

        //             if(lastState == DGS_NONE) { // Open Speaker
        //                 if(dgState == DGS_RIGHT) { // Right Speaker Open

        //                     if(st == 0) {
        //                         borders.setImage(borderNames[lindex]);
        //                         nameBox.setImage(nameBoxNames[lindex]);

        //                         borders.setImageScale((sStart, sStart) * curScale);
        //                         leftNameTag.setAlpha(0.0);
        //                     } else {
        //                         borders.setImageScale((curScale, curScale));
        //                         borders.setAlpha(curAlpha);
        //                     }
                            
        //                     leftSpeaker.setImageScale((speakScales[findex], speakScales[findex]) * curScale);
        //                     leftSpeaker.setPos(imgCenter + (speakXs[lindex], 0) * curScale);
        //                     leftSpeaker.setAlpha(curAlpha);

        //                     rightSpeaker.setImageScale((speakScales[lindex], speakScales[lindex]) * curScale);
        //                     rightSpeaker.setPos(imgCenter - (speakXs[findex], 0) * curScale);
        //                     rightSpeaker.setAlpha(curAlpha);

        //                     rightNameTag.setAlpha(curAlpha);
        //                     rightNameTag.setTextScale(curScale * NAMETAG_SCALE);
        //                 } else { // Left Speaker Open

        //                     if(st == 0) {
        //                         borders.setImage(borderNames[findex]);
        //                         nameBox.setImage(nameBoxNames[findex]);

        //                         borders.setImageScale((sStart, sStart) * curScale);
        //                         rightNameTag.setAlpha(0.0);
        //                     } else {
        //                         borders.setImageScale((curScale, curScale));
        //                         borders.setAlpha(curAlpha);
        //                     }
                            
        //                     leftSpeaker.setImageScale((speakScales[lindex], speakScales[lindex]) * curScale);
        //                     leftSpeaker.setPos(imgCenter + (speakXs[findex], 0) * curScale);
        //                     leftSpeaker.setAlpha(curAlpha);

        //                     rightSpeaker.setImageScale((speakScales[findex], speakScales[findex]) * curScale);
        //                     rightSpeaker.setPos(imgCenter - (speakXs[lindex], 0) * curScale);
        //                     rightSpeaker.setAlpha(curAlpha);

        //                     leftNameTag.setAlpha(curAlpha);
        //                     leftNameTag.setTextScale(curScale * NAMETAG_SCALE);
        //                 }

        //                 textBox.setImageScale((curScale, curScale));
        //                 textBox.setAlpha(curAlpha);

        //                 nameBox.setImageScale((curScale, curScale));
        //                 nameBox.setAlpha(curAlpha);
        //             }
        //         } // openTime
        //     } // animTime
        // }

        // // if(stateTime() > 70) {
        // //     swapSides();
        // // }

        // tick++;
    // }
}
